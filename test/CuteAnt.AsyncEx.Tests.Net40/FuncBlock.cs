using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

namespace CuteAnt.AsyncEx
{
    /// <summary>
    /// A dataflow block which uses a function to generate its items.
    /// </summary>
    /// <typeparam name="T">The type of items generated by the function.</typeparam>
    /// <remarks>
    /// <para>If the function returns, then this block is completed.</para>
    /// <para>If the function throws <see cref="OperationCanceledException"/>, then this block is completed.</para>
    /// <para>If the function throws another exception, then this block is faulted.</para>
    /// <para>If this block is cancelled (by cancelling the <see cref="DataflowBlockOptions.CancellationToken"/> member of the <see cref="DataflowBlockOptions"/>), then this block is cancelled and then the function is cancelled by having its method argument throw <see cref="OperationCanceledException"/>.</para>
    /// <para>If this block is completed (by calling <see cref="Complete"/>), then this block is completed and then the function is cancelled by having its method argument throw <see cref="OperationCanceledException"/>.</para>
    /// <para>If this block is faulted (by calling <see cref="IDataflowBlock.Fault"/>), then this block is faulted and then the function is cancelled by having its method argument throw <see cref="OperationCanceledException"/>.</para>
    /// </remarks>
    [DebuggerDisplay("{GetDebuggerDisplayString,nq}")]
    [DebuggerTypeProxy(typeof(FuncBlock<>.DebugView))]
    public sealed class FuncBlock<T> : IReceivableSourceBlock<T>, IDisposable
    {
        /// <summary>
        /// The internal buffer block, holding items that have been generated by the function but not yet passed on.
        /// </summary>
        private readonly BufferBlock<T> _block;

        /// <summary>
        /// The CTS used to signal the function to stop.
        /// </summary>
        private readonly CancellationTokenSource _functionCancellationTokenSource;

        /// <summary>
        /// The options used to construct this block.
        /// </summary>
        private readonly DataflowBlockOptions _options;

        /// <summary>
        /// The producer function.
        /// </summary>
        private readonly Task _function;

        internal string GetDebuggerDisplayString
        {
            get
            {
                return Name + ", State = " + GetStateForDebugger;
            }
        }

        internal State GetStateForDebugger
        {
            get
            {
                var blockTask = _block.Completion;
                if (!_function.IsCompleted)
                {
                    if (!blockTask.IsCompleted)
                        return State.Running;
                    if (blockTask.IsCanceled)
                        return State.Canceling;
                    if (blockTask.IsFaulted)
                        return State.Faulting;
                    return State.Completing;
                }
                if (blockTask.IsCompleted)
                {
                    if (blockTask.IsCanceled)
                        return State.Canceled;
                    if (blockTask.IsFaulted)
                        return State.Faulted;
                    return State.Completed;
                }
                if (_function.IsFaulted)
                    return State.Faulting;
                return State.Completing;
            }
        }

        internal enum State
        {
            Running,
            Completing,
            Completed,
            Faulting,
            Faulted,
            Canceling,
            Canceled,
        }

        /// <summary>
        /// Initializes the block and CTS.
        /// </summary>
        /// <param name="dataflowBlockOptions">The options with which to configure this block.</param>
        private FuncBlock(DataflowBlockOptions dataflowBlockOptions)
        {
            _options = dataflowBlockOptions ?? new DataflowBlockOptions();
            _block = new BufferBlock<T>(_options);

            // Can't use a linked CTS here, becuase it would cause a race condition if dataflowBlockOptions.CancellationToken is canceled.
            //  (dataflowBlockOptions.CancellationToken would try to cancel the BufferBlock, while the function being canceled would try to complete the BufferBlock).
            // Instead, just always have the BufferBlock completion cancel the function.
            _functionCancellationTokenSource = new CancellationTokenSource();
            _block.Completion.ContinueWith(_ => _functionCancellationTokenSource.Cancel(), TaskScheduler.Default);
        }

        /// <summary>
        /// Initializes the block with the specified options and a function which takes a cancellation token.
        /// </summary>
        /// <param name="function">The asynchronous function which generates items. If this function returns or throws an <see cref="OperationCanceledException"/>, then this block will complete. If this function throws another exception, then this block will fault. The first argument to this function ("send") is an asynchronous method to send an item to this block; the "send" method will throw <see cref="OperationCanceledException"/> if the block has completed and the function should exit. The second argument to this function is a cancellation token that will be cancelled if the block has completed and the function should exit.</param>
        /// <param name="dataflowBlockOptions">The options with which to configure this block. If the cancellation token is cancelled, then this block will cancel and then the next call to the function's "send" method will throw <see cref="OperationCanceledException"/>.</param>
        public FuncBlock(Func<Func<T, Task>, CancellationToken, Task> function, DataflowBlockOptions dataflowBlockOptions)
            : this(dataflowBlockOptions)
        {
            Func<Task> operation = () => function(FunctionSendAsync, _functionCancellationTokenSource.Token);
            _function = new TaskFactory(_options.TaskScheduler).StartNew(operation).Unwrap();
            _function.ContinueWith(PropagateResult, TaskScheduler.Default);
        }

        /// <summary>
        /// Initializes the block with a function which takes a cancellation token.
        /// </summary>
        /// <param name="function">The asynchronous function which generates items. If this function returns or throws an <see cref="OperationCanceledException"/>, then this block will complete. If this function throws another exception, then this block will fault. The first argument to this function ("send") is an asynchronous method to send an item to this block; the "send" method will throw <see cref="OperationCanceledException"/> if the block has completed and the function should exit. The second argument to this function is a cancellation token that will be cancelled if the block has completed and the function should exit.</param>
        public FuncBlock(Func<Func<T, Task>, CancellationToken, Task> function)
            : this(function, null)
        {
        }

        /// <summary>
        /// Initializes the block with the specified options and a function which does not take a cancellation token.
        /// </summary>
        /// <param name="function">The asynchronous function which generates items. If this function returns or throws an <see cref="OperationCanceledException"/>, then this block will complete. If this function throws another exception, then this block will fault. The argument to this function ("send") is an asynchronous method to send an item to this block; the "send" method will throw <see cref="OperationCanceledException"/> if the block has completed and the function should exit.</param>
        /// <param name="dataflowBlockOptions">The options with which to configure this block. If the cancellation token is cancelled, then this block will cancel and then the next call to the function's "send" method will throw <see cref="OperationCanceledException"/>.</param>
        public FuncBlock(Func<Func<T, Task>, Task> function, DataflowBlockOptions dataflowBlockOptions)
            : this(dataflowBlockOptions)
        {
            Func<Task> operation = () => function(FunctionSendAsync);
            _function = new TaskFactory(_options.TaskScheduler).StartNew(operation).Unwrap();
            _function.ContinueWith(PropagateResult, TaskScheduler.Default);
        }

        /// <summary>
        /// Initializes the block with a function which does not take a cancellation token.
        /// </summary>
        /// <param name="function">The asynchronous function which generates items. If this function returns or throws an <see cref="OperationCanceledException"/>, then this block will complete. If this function throws another exception, then this block will fault. The argument to this function ("send") is an asynchronous method to send an item to this block; the "send" method will throw <see cref="OperationCanceledException"/> if the block has completed and the function should exit.</param>
        public FuncBlock(Func<Func<T, Task>, Task> function)
            : this(function, null)
        {
        }

        /// <summary>
        /// Releases resources used by this instance. Use of this instance after disposal is undefined.
        /// </summary>
        public void Dispose()
        {
            _functionCancellationTokenSource.Dispose();
        }

        /// <summary>
        /// The method called by the function to send an item to the block.
        /// </summary>
        /// <param name="item">The item to send.</param>
        private async Task FunctionSendAsync(T item)
        {
            var success = await _block.SendAsync(item, _functionCancellationTokenSource.Token).ConfigureAwait(false);
            if (!success)
                throw new OperationCanceledException();
        }

        /// <summary>
        /// The continuation applied to the function to interpret an exception as a fault and a success/cancel as a completion.
        /// </summary>
        /// <param name="function">The task representing the function.</param>
        private void PropagateResult(Task function)
        {
            if (function.Status == TaskStatus.Faulted)
                ((IDataflowBlock)_block).Fault(function.Exception.InnerException);
            else
                _block.Complete();
        }

        /// <summary>
        /// Gets the name for this block.
        /// </summary>
        public string Name
        {
            get
            {
                return String.Format(_options.NameFormat, GetType().Name, _block.Completion.Id);
            }
        }

        /// <summary>
        /// Attempts to synchronously receive an available output item from the block.
        /// </summary>
        /// <param name="filter">The predicate value must successfully pass in order for it to be received. <paramref name="filter"/> may be <c>null</c>, in which case all items will pass.</param>
        /// <param name="item">The item received from the source.</param>
        /// <returns><c>true</c> if an item could be received; otherwise, <c>false</c>.</returns>
        public bool TryReceive(Predicate<T> filter, out T item)
        {
            return _block.TryReceive(filter, out item);
        }

        /// <summary>
        /// Attempts to synchronously receive all available items from the block.
        /// </summary>
        /// <param name="items">The items received from the source.</param>
        /// <returns><c>true</c> if one or more items could be received; otherwise, <c>false</c>.</returns>
        public bool TryReceiveAll(out IList<T> items)
        {
            return _block.TryReceiveAll(out items);
        }

        T ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target, out bool messageConsumed)
        {
            return ((IReceivableSourceBlock<T>)_block).ConsumeMessage(messageHeader, target, out messageConsumed);
        }

        /// <summary>
        /// Links the block to the specified <see cref="ITargetBlock{TInput}"/>.
        /// </summary>
        /// <param name="target">The <see cref="ITargetBlock{TInput}"/> to which to connect this source.</param>
        /// <param name="linkOptions">A <see cref="DataflowLinkOptions"/> instance that configures the link.</param>
        /// <returns>An IDisposable that, upon calling Dispose, will unlink the source from the target.</returns>
        public IDisposable LinkTo(ITargetBlock<T> target, DataflowLinkOptions linkOptions)
        {
            return _block.LinkTo(target, linkOptions);
        }

        void ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<T> target)
        {
            ((IReceivableSourceBlock<T>)_block).ReleaseReservation(messageHeader, target);
        }

        bool ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target)
        {
            return ((IReceivableSourceBlock<T>)_block).ReserveMessage(messageHeader, target);
        }

        /// <summary>
        /// Signals to the block that it should not produce any more messages. This block will complete and then the next call to the function's "send" method will throw <see cref="OperationCanceledException"/>.
        /// </summary>
        public void Complete()
        {
            _block.Complete();
        }

        /// <summary>
        /// Gets a <see cref="Task"/> that represents the asynchronous operation and completion of the dataflow block.
        /// </summary>
        public Task Completion
        {
            get { return _block.Completion; }
        }

        /// <summary>
        /// Signals to the block that it should enter a fault state and not produce any more messages. This block will fault and then the next call to the function's "send" method will throw <see cref="OperationCanceledException"/>.
        /// </summary>
        void IDataflowBlock.Fault(Exception exception)
        {
            ((IDataflowBlock)_block).Fault(exception);
        }

        [DebuggerNonUserCode]
        internal sealed class DebugView
        {
            private readonly FuncBlock<T> _block;

            public DebugView(FuncBlock<T> block)
            {
                _block = block;
            }

            public State State { get { return _block.GetStateForDebugger; } }

            public bool IsFunctionCancellationRequested { get { return _block._functionCancellationTokenSource.IsCancellationRequested; } }

            public BufferBlock<T> BufferBlock { get { return _block._block; } }

            public Task ProducerTask { get { return _block._function; } }
        }
    }
}
