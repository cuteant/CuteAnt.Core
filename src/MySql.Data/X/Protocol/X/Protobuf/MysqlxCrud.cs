// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Mysqlx.Crud {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal static partial class MysqlxCrud {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Column__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Column, global::Mysqlx.Crud.Column.Builder> internal__static_Mysqlx_Crud_Column__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Projection__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Projection, global::Mysqlx.Crud.Projection.Builder> internal__static_Mysqlx_Crud_Projection__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Collection__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Collection, global::Mysqlx.Crud.Collection.Builder> internal__static_Mysqlx_Crud_Collection__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Limit__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Limit, global::Mysqlx.Crud.Limit.Builder> internal__static_Mysqlx_Crud_Limit__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Order__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Order, global::Mysqlx.Crud.Order.Builder> internal__static_Mysqlx_Crud_Order__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_UpdateOperation__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.UpdateOperation, global::Mysqlx.Crud.UpdateOperation.Builder> internal__static_Mysqlx_Crud_UpdateOperation__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Find__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Find, global::Mysqlx.Crud.Find.Builder> internal__static_Mysqlx_Crud_Find__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Insert__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Insert, global::Mysqlx.Crud.Insert.Builder> internal__static_Mysqlx_Crud_Insert__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Insert_TypedRow__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Insert.Types.TypedRow, global::Mysqlx.Crud.Insert.Types.TypedRow.Builder> internal__static_Mysqlx_Crud_Insert_TypedRow__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Update__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Update, global::Mysqlx.Crud.Update.Builder> internal__static_Mysqlx_Crud_Update__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Crud_Delete__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Delete, global::Mysqlx.Crud.Delete.Builder> internal__static_Mysqlx_Crud_Delete__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static MysqlxCrud() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChFteXNxbHhfY3J1ZC5wcm90bxILTXlzcWx4LkNydWQaEW15c3FseF9leHBy", 
            "LnByb3RvGhZteXNxbHhfZGF0YXR5cGVzLnByb3RvIlsKBkNvbHVtbhIMCgRu", 
            "YW1lGAEgASgJEg0KBWFsaWFzGAIgASgJEjQKDWRvY3VtZW50X3BhdGgYAyAD", 
            "KAsyHS5NeXNxbHguRXhwci5Eb2N1bWVudFBhdGhJdGVtIj4KClByb2plY3Rp", 
            "b24SIQoGc291cmNlGAEgAigLMhEuTXlzcWx4LkV4cHIuRXhwchINCgVhbGlh", 
            "cxgCIAEoCSIqCgpDb2xsZWN0aW9uEgwKBG5hbWUYASACKAkSDgoGc2NoZW1h", 
            "GAIgASgJIioKBUxpbWl0EhEKCXJvd19jb3VudBgBIAIoBBIOCgZvZmZzZXQY", 
            "AiABKAQifgoFT3JkZXISHwoEZXhwchgBIAIoCzIRLk15c3FseC5FeHByLkV4", 
            "cHISNAoJZGlyZWN0aW9uGAIgASgOMhwuTXlzcWx4LkNydWQuT3JkZXIuRGly", 
            "ZWN0aW9uOgNBU0MiHgoJRGlyZWN0aW9uEgcKA0FTQxABEggKBERFU0MQAiKa", 
            "AgoPVXBkYXRlT3BlcmF0aW9uEi0KBnNvdXJjZRgBIAIoCzIdLk15c3FseC5F", 
            "eHByLkNvbHVtbklkZW50aWZpZXISOgoJb3BlcmF0aW9uGAIgAigOMicuTXlz", 
            "cWx4LkNydWQuVXBkYXRlT3BlcmF0aW9uLlVwZGF0ZVR5cGUSIAoFdmFsdWUY", 
            "AyABKAsyES5NeXNxbHguRXhwci5FeHByInoKClVwZGF0ZVR5cGUSBwoDU0VU", 
            "EAESDwoLSVRFTV9SRU1PVkUQAhIMCghJVEVNX1NFVBADEhAKDElURU1fUkVQ", 
            "TEFDRRAEEg4KCklURU1fTUVSR0UQBRIQCgxBUlJBWV9JTlNFUlQQBhIQCgxB", 
            "UlJBWV9BUFBFTkQQByLyAgoERmluZBIrCgpjb2xsZWN0aW9uGAIgAigLMhcu", 
            "TXlzcWx4LkNydWQuQ29sbGVjdGlvbhIqCgpkYXRhX21vZGVsGAMgASgOMhYu", 
            "TXlzcWx4LkNydWQuRGF0YU1vZGVsEisKCnByb2plY3Rpb24YBCADKAsyFy5N", 
            "eXNxbHguQ3J1ZC5Qcm9qZWN0aW9uEiMKCGNyaXRlcmlhGAUgASgLMhEuTXlz", 
            "cWx4LkV4cHIuRXhwchImCgRhcmdzGAsgAygLMhguTXlzcWx4LkRhdGF0eXBl", 
            "cy5TY2FsYXISIQoFbGltaXQYBiABKAsyEi5NeXNxbHguQ3J1ZC5MaW1pdBIh", 
            "CgVvcmRlchgHIAMoCzISLk15c3FseC5DcnVkLk9yZGVyEiMKCGdyb3VwaW5n", 
            "GAggAygLMhEuTXlzcWx4LkV4cHIuRXhwchIsChFncm91cGluZ19jcml0ZXJp", 
            "YRgJIAEoCzIRLk15c3FseC5FeHByLkV4cHIi4wEKBkluc2VydBIrCgpjb2xs", 
            "ZWN0aW9uGAEgAigLMhcuTXlzcWx4LkNydWQuQ29sbGVjdGlvbhIqCgpkYXRh", 
            "X21vZGVsGAIgASgOMhYuTXlzcWx4LkNydWQuRGF0YU1vZGVsEicKCnByb2pl", 
            "Y3Rpb24YAyADKAsyEy5NeXNxbHguQ3J1ZC5Db2x1bW4SKQoDcm93GAQgAygL", 
            "MhwuTXlzcWx4LkNydWQuSW5zZXJ0LlR5cGVkUm93GiwKCFR5cGVkUm93EiAK", 
            "BWZpZWxkGAEgAygLMhEuTXlzcWx4LkV4cHIuRXhwciKlAgoGVXBkYXRlEisK", 
            "CmNvbGxlY3Rpb24YAiACKAsyFy5NeXNxbHguQ3J1ZC5Db2xsZWN0aW9uEioK", 
            "CmRhdGFfbW9kZWwYAyABKA4yFi5NeXNxbHguQ3J1ZC5EYXRhTW9kZWwSIwoI", 
            "Y3JpdGVyaWEYBCABKAsyES5NeXNxbHguRXhwci5FeHByEiYKBGFyZ3MYCCAD", 
            "KAsyGC5NeXNxbHguRGF0YXR5cGVzLlNjYWxhchIhCgVsaW1pdBgFIAEoCzIS", 
            "Lk15c3FseC5DcnVkLkxpbWl0EiEKBW9yZGVyGAYgAygLMhIuTXlzcWx4LkNy", 
            "dWQuT3JkZXISLwoJb3BlcmF0aW9uGAcgAygLMhwuTXlzcWx4LkNydWQuVXBk", 
            "YXRlT3BlcmF0aW9uIvQBCgZEZWxldGUSKwoKY29sbGVjdGlvbhgBIAIoCzIX", 
            "Lk15c3FseC5DcnVkLkNvbGxlY3Rpb24SKgoKZGF0YV9tb2RlbBgCIAEoDjIW", 
            "Lk15c3FseC5DcnVkLkRhdGFNb2RlbBIjCghjcml0ZXJpYRgDIAEoCzIRLk15", 
            "c3FseC5FeHByLkV4cHISJgoEYXJncxgGIAMoCzIYLk15c3FseC5EYXRhdHlw", 
            "ZXMuU2NhbGFyEiEKBWxpbWl0GAQgASgLMhIuTXlzcWx4LkNydWQuTGltaXQS", 
            "IQoFb3JkZXIYBSADKAsyEi5NeXNxbHguQ3J1ZC5PcmRlciokCglEYXRhTW9k", 
            "ZWwSDAoIRE9DVU1FTlQQARIJCgVUQUJMRRACQh4KHGNvbS5teXNxbC5jai5t", 
          "eXNxbHgucHJvdG9idWY="));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Mysqlx_Crud_Column__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Mysqlx_Crud_Column__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Column, global::Mysqlx.Crud.Column.Builder>(internal__static_Mysqlx_Crud_Column__Descriptor,
                new string[] { "Name", "Alias", "DocumentPath", });
        internal__static_Mysqlx_Crud_Projection__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Mysqlx_Crud_Projection__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Projection, global::Mysqlx.Crud.Projection.Builder>(internal__static_Mysqlx_Crud_Projection__Descriptor,
                new string[] { "Source", "Alias", });
        internal__static_Mysqlx_Crud_Collection__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Mysqlx_Crud_Collection__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Collection, global::Mysqlx.Crud.Collection.Builder>(internal__static_Mysqlx_Crud_Collection__Descriptor,
                new string[] { "Name", "Schema", });
        internal__static_Mysqlx_Crud_Limit__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Mysqlx_Crud_Limit__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Limit, global::Mysqlx.Crud.Limit.Builder>(internal__static_Mysqlx_Crud_Limit__Descriptor,
                new string[] { "RowCount", "Offset", });
        internal__static_Mysqlx_Crud_Order__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Mysqlx_Crud_Order__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Order, global::Mysqlx.Crud.Order.Builder>(internal__static_Mysqlx_Crud_Order__Descriptor,
                new string[] { "Expr", "Direction", });
        internal__static_Mysqlx_Crud_UpdateOperation__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Mysqlx_Crud_UpdateOperation__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.UpdateOperation, global::Mysqlx.Crud.UpdateOperation.Builder>(internal__static_Mysqlx_Crud_UpdateOperation__Descriptor,
                new string[] { "Source", "Operation", "Value", });
        internal__static_Mysqlx_Crud_Find__Descriptor = Descriptor.MessageTypes[6];
        internal__static_Mysqlx_Crud_Find__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Find, global::Mysqlx.Crud.Find.Builder>(internal__static_Mysqlx_Crud_Find__Descriptor,
                new string[] { "Collection", "DataModel", "Projection", "Criteria", "Args", "Limit", "Order", "Grouping", "GroupingCriteria", });
        internal__static_Mysqlx_Crud_Insert__Descriptor = Descriptor.MessageTypes[7];
        internal__static_Mysqlx_Crud_Insert__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Insert, global::Mysqlx.Crud.Insert.Builder>(internal__static_Mysqlx_Crud_Insert__Descriptor,
                new string[] { "Collection", "DataModel", "Projection", "Row", });
        internal__static_Mysqlx_Crud_Insert_TypedRow__Descriptor = internal__static_Mysqlx_Crud_Insert__Descriptor.NestedTypes[0];
        internal__static_Mysqlx_Crud_Insert_TypedRow__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Insert.Types.TypedRow, global::Mysqlx.Crud.Insert.Types.TypedRow.Builder>(internal__static_Mysqlx_Crud_Insert_TypedRow__Descriptor,
                new string[] { "Field", });
        internal__static_Mysqlx_Crud_Update__Descriptor = Descriptor.MessageTypes[8];
        internal__static_Mysqlx_Crud_Update__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Update, global::Mysqlx.Crud.Update.Builder>(internal__static_Mysqlx_Crud_Update__Descriptor,
                new string[] { "Collection", "DataModel", "Criteria", "Args", "Limit", "Order", "Operation", });
        internal__static_Mysqlx_Crud_Delete__Descriptor = Descriptor.MessageTypes[9];
        internal__static_Mysqlx_Crud_Delete__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Crud.Delete, global::Mysqlx.Crud.Delete.Builder>(internal__static_Mysqlx_Crud_Delete__Descriptor,
                new string[] { "Collection", "DataModel", "Criteria", "Args", "Limit", "Order", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::Mysqlx.Expr.MysqlxExpr.Descriptor, 
          global::Mysqlx.Datatypes.MysqlxDatatypes.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Enums
  internal enum DataModel {
    DOCUMENT = 1,
    TABLE = 2,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Column : pb::GeneratedMessage<Column, Column.Builder> {
    private Column() { }
    private static readonly Column defaultInstance = new Column().MakeReadOnly();
    private static readonly string[] _columnFieldNames = new string[] { "alias", "document_path", "name" };
    private static readonly uint[] _columnFieldTags = new uint[] { 18, 26, 10 };
    public static Column DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Column DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Column ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Column__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Column, Column.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Column__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int AliasFieldNumber = 2;
    private bool hasAlias;
    private string alias_ = "";
    public bool HasAlias {
      get { return hasAlias; }
    }
    public string Alias {
      get { return alias_; }
    }
    
    public const int DocumentPathFieldNumber = 3;
    private pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem> documentPath_ = new pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem>();
    public scg::IList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
      get { return documentPath_; }
    }
    public int DocumentPathCount {
      get { return documentPath_.Count; }
    }
    public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
      return documentPath_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _columnFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[2], Name);
      }
      if (hasAlias) {
        output.WriteString(2, field_names[0], Alias);
      }
      if (documentPath_.Count > 0) {
        output.WriteMessageArray(3, field_names[1], documentPath_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Name);
      }
      if (hasAlias) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Alias);
      }
      foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Column ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Column ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Column ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Column ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Column ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Column ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Column ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Column ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Column ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Column ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Column MakeReadOnly() {
      documentPath_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Column prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Column, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Column cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Column result;
      
      private Column PrepareBuilder() {
        if (resultIsReadOnly) {
          Column original = result;
          result = new Column();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Column MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Column.Descriptor; }
      }
      
      public override Column DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Column.DefaultInstance; }
      }
      
      public override Column BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Column) {
          return MergeFrom((Column) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Column other) {
        if (other == global::Mysqlx.Crud.Column.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasAlias) {
          Alias = other.Alias;
        }
        if (other.documentPath_.Count != 0) {
          result.documentPath_.Add(other.documentPath_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_columnFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _columnFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasAlias = input.ReadString(ref result.alias_);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.documentPath_, global::Mysqlx.Expr.DocumentPathItem.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasAlias {
        get { return result.hasAlias; }
      }
      public string Alias {
        get { return result.Alias; }
        set { SetAlias(value); }
      }
      public Builder SetAlias(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAlias = true;
        result.alias_ = value;
        return this;
      }
      public Builder ClearAlias() {
        PrepareBuilder();
        result.hasAlias = false;
        result.alias_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
        get { return PrepareBuilder().documentPath_; }
      }
      public int DocumentPathCount {
        get { return result.DocumentPathCount; }
      }
      public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
        return result.GetDocumentPath(index);
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_[index] = value;
        return this;
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_.Add(value);
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeDocumentPath(scg::IEnumerable<global::Mysqlx.Expr.DocumentPathItem> values) {
        PrepareBuilder();
        result.documentPath_.Add(values);
        return this;
      }
      public Builder ClearDocumentPath() {
        PrepareBuilder();
        result.documentPath_.Clear();
        return this;
      }
    }
    static Column() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Projection : pb::GeneratedMessage<Projection, Projection.Builder> {
    private Projection() { }
    private static readonly Projection defaultInstance = new Projection().MakeReadOnly();
    private static readonly string[] _projectionFieldNames = new string[] { "alias", "source" };
    private static readonly uint[] _projectionFieldTags = new uint[] { 18, 10 };
    public static Projection DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Projection DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Projection ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Projection__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Projection, Projection.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Projection__FieldAccessorTable; }
    }
    
    public const int SourceFieldNumber = 1;
    private bool hasSource;
    private global::Mysqlx.Expr.Expr source_;
    public bool HasSource {
      get { return hasSource; }
    }
    public global::Mysqlx.Expr.Expr Source {
      get { return source_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int AliasFieldNumber = 2;
    private bool hasAlias;
    private string alias_ = "";
    public bool HasAlias {
      get { return hasAlias; }
    }
    public string Alias {
      get { return alias_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSource) return false;
        if (!Source.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _projectionFieldNames;
      if (hasSource) {
        output.WriteMessage(1, field_names[1], Source);
      }
      if (hasAlias) {
        output.WriteString(2, field_names[0], Alias);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSource) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Source);
      }
      if (hasAlias) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Alias);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Projection ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Projection ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Projection ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Projection ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Projection ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Projection ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Projection ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Projection ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Projection ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Projection ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Projection MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Projection prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Projection, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Projection cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Projection result;
      
      private Projection PrepareBuilder() {
        if (resultIsReadOnly) {
          Projection original = result;
          result = new Projection();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Projection MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Projection.Descriptor; }
      }
      
      public override Projection DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Projection.DefaultInstance; }
      }
      
      public override Projection BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Projection) {
          return MergeFrom((Projection) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Projection other) {
        if (other == global::Mysqlx.Crud.Projection.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSource) {
          MergeSource(other.Source);
        }
        if (other.HasAlias) {
          Alias = other.Alias;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_projectionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _projectionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasSource) {
                subBuilder.MergeFrom(Source);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Source = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              result.hasAlias = input.ReadString(ref result.alias_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSource {
       get { return result.hasSource; }
      }
      public global::Mysqlx.Expr.Expr Source {
        get { return result.Source; }
        set { SetSource(value); }
      }
      public Builder SetSource(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSource = true;
        result.source_ = value;
        return this;
      }
      public Builder SetSource(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSource = true;
        result.source_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSource(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSource &&
            result.source_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.source_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.source_).MergeFrom(value).BuildPartial();
        } else {
          result.source_ = value;
        }
        result.hasSource = true;
        return this;
      }
      public Builder ClearSource() {
        PrepareBuilder();
        result.hasSource = false;
        result.source_ = null;
        return this;
      }
      
      public bool HasAlias {
        get { return result.hasAlias; }
      }
      public string Alias {
        get { return result.Alias; }
        set { SetAlias(value); }
      }
      public Builder SetAlias(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAlias = true;
        result.alias_ = value;
        return this;
      }
      public Builder ClearAlias() {
        PrepareBuilder();
        result.hasAlias = false;
        result.alias_ = "";
        return this;
      }
    }
    static Projection() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Collection : pb::GeneratedMessage<Collection, Collection.Builder> {
    private Collection() { }
    private static readonly Collection defaultInstance = new Collection().MakeReadOnly();
    private static readonly string[] _collectionFieldNames = new string[] { "name", "schema" };
    private static readonly uint[] _collectionFieldTags = new uint[] { 10, 18 };
    public static Collection DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Collection DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Collection ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Collection__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Collection, Collection.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Collection__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int SchemaFieldNumber = 2;
    private bool hasSchema;
    private string schema_ = "";
    public bool HasSchema {
      get { return hasSchema; }
    }
    public string Schema {
      get { return schema_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _collectionFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (hasSchema) {
        output.WriteString(2, field_names[1], Schema);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Name);
      }
      if (hasSchema) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Schema);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Collection ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Collection ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Collection ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Collection ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Collection ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Collection ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Collection ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Collection ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Collection ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Collection ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Collection MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Collection prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Collection, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Collection cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Collection result;
      
      private Collection PrepareBuilder() {
        if (resultIsReadOnly) {
          Collection original = result;
          result = new Collection();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Collection MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Collection.Descriptor; }
      }
      
      public override Collection DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Collection.DefaultInstance; }
      }
      
      public override Collection BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Collection) {
          return MergeFrom((Collection) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Collection other) {
        if (other == global::Mysqlx.Crud.Collection.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasSchema) {
          Schema = other.Schema;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_collectionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _collectionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasSchema = input.ReadString(ref result.schema_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasSchema {
        get { return result.hasSchema; }
      }
      public string Schema {
        get { return result.Schema; }
        set { SetSchema(value); }
      }
      public Builder SetSchema(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSchema = true;
        result.schema_ = value;
        return this;
      }
      public Builder ClearSchema() {
        PrepareBuilder();
        result.hasSchema = false;
        result.schema_ = "";
        return this;
      }
    }
    static Collection() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Limit : pb::GeneratedMessage<Limit, Limit.Builder> {
    private Limit() { }
    private static readonly Limit defaultInstance = new Limit().MakeReadOnly();
    private static readonly string[] _limitFieldNames = new string[] { "offset", "row_count" };
    private static readonly uint[] _limitFieldTags = new uint[] { 16, 8 };
    public static Limit DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Limit DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Limit ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Limit__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Limit, Limit.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Limit__FieldAccessorTable; }
    }
    
    public const int RowCountFieldNumber = 1;
    private bool hasRowCount;
    private ulong rowCount_;
    public bool HasRowCount {
      get { return hasRowCount; }
    }
    [global::System.CLSCompliant(false)]
    public ulong RowCount {
      get { return rowCount_; }
    }
    
    public const int OffsetFieldNumber = 2;
    private bool hasOffset;
    private ulong offset_;
    public bool HasOffset {
      get { return hasOffset; }
    }
    [global::System.CLSCompliant(false)]
    public ulong Offset {
      get { return offset_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRowCount) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _limitFieldNames;
      if (hasRowCount) {
        output.WriteUInt64(1, field_names[1], RowCount);
      }
      if (hasOffset) {
        output.WriteUInt64(2, field_names[0], Offset);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasRowCount) {
        size += pb::CodedOutputStream.ComputeUInt64Size(1, RowCount);
      }
      if (hasOffset) {
        size += pb::CodedOutputStream.ComputeUInt64Size(2, Offset);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Limit ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Limit ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Limit ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Limit ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Limit ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Limit ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Limit ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Limit ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Limit ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Limit ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Limit MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Limit prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Limit, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Limit cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Limit result;
      
      private Limit PrepareBuilder() {
        if (resultIsReadOnly) {
          Limit original = result;
          result = new Limit();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Limit MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Limit.Descriptor; }
      }
      
      public override Limit DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Limit.DefaultInstance; }
      }
      
      public override Limit BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Limit) {
          return MergeFrom((Limit) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Limit other) {
        if (other == global::Mysqlx.Crud.Limit.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRowCount) {
          RowCount = other.RowCount;
        }
        if (other.HasOffset) {
          Offset = other.Offset;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_limitFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _limitFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasRowCount = input.ReadUInt64(ref result.rowCount_);
              break;
            }
            case 16: {
              result.hasOffset = input.ReadUInt64(ref result.offset_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRowCount {
        get { return result.hasRowCount; }
      }
      [global::System.CLSCompliant(false)]
      public ulong RowCount {
        get { return result.RowCount; }
        set { SetRowCount(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetRowCount(ulong value) {
        PrepareBuilder();
        result.hasRowCount = true;
        result.rowCount_ = value;
        return this;
      }
      public Builder ClearRowCount() {
        PrepareBuilder();
        result.hasRowCount = false;
        result.rowCount_ = 0UL;
        return this;
      }
      
      public bool HasOffset {
        get { return result.hasOffset; }
      }
      [global::System.CLSCompliant(false)]
      public ulong Offset {
        get { return result.Offset; }
        set { SetOffset(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetOffset(ulong value) {
        PrepareBuilder();
        result.hasOffset = true;
        result.offset_ = value;
        return this;
      }
      public Builder ClearOffset() {
        PrepareBuilder();
        result.hasOffset = false;
        result.offset_ = 0UL;
        return this;
      }
    }
    static Limit() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Order : pb::GeneratedMessage<Order, Order.Builder> {
    private Order() { }
    private static readonly Order defaultInstance = new Order().MakeReadOnly();
    private static readonly string[] _orderFieldNames = new string[] { "direction", "expr" };
    private static readonly uint[] _orderFieldTags = new uint[] { 16, 10 };
    public static Order DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Order DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Order ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Order__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Order, Order.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Order__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Direction {
        ASC = 1,
        DESC = 2,
      }
      
    }
    #endregion
    
    public const int ExprFieldNumber = 1;
    private bool hasExpr;
    private global::Mysqlx.Expr.Expr expr_;
    public bool HasExpr {
      get { return hasExpr; }
    }
    public global::Mysqlx.Expr.Expr Expr {
      get { return expr_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int DirectionFieldNumber = 2;
    private bool hasDirection;
    private global::Mysqlx.Crud.Order.Types.Direction direction_ = global::Mysqlx.Crud.Order.Types.Direction.ASC;
    public bool HasDirection {
      get { return hasDirection; }
    }
    public global::Mysqlx.Crud.Order.Types.Direction Direction {
      get { return direction_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasExpr) return false;
        if (!Expr.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _orderFieldNames;
      if (hasExpr) {
        output.WriteMessage(1, field_names[1], Expr);
      }
      if (hasDirection) {
        output.WriteEnum(2, field_names[0], (int) Direction, Direction);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasExpr) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Expr);
      }
      if (hasDirection) {
        size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Direction);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Order ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Order MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Order prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Order, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Order cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Order result;
      
      private Order PrepareBuilder() {
        if (resultIsReadOnly) {
          Order original = result;
          result = new Order();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Order MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Order.Descriptor; }
      }
      
      public override Order DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Order.DefaultInstance; }
      }
      
      public override Order BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Order) {
          return MergeFrom((Order) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Order other) {
        if (other == global::Mysqlx.Crud.Order.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasExpr) {
          MergeExpr(other.Expr);
        }
        if (other.HasDirection) {
          Direction = other.Direction;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_orderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _orderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasExpr) {
                subBuilder.MergeFrom(Expr);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Expr = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.direction_, out unknown)) {
                result.hasDirection = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasExpr {
       get { return result.hasExpr; }
      }
      public global::Mysqlx.Expr.Expr Expr {
        get { return result.Expr; }
        set { SetExpr(value); }
      }
      public Builder SetExpr(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasExpr = true;
        result.expr_ = value;
        return this;
      }
      public Builder SetExpr(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasExpr = true;
        result.expr_ = builderForValue.Build();
        return this;
      }
      public Builder MergeExpr(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasExpr &&
            result.expr_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.expr_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.expr_).MergeFrom(value).BuildPartial();
        } else {
          result.expr_ = value;
        }
        result.hasExpr = true;
        return this;
      }
      public Builder ClearExpr() {
        PrepareBuilder();
        result.hasExpr = false;
        result.expr_ = null;
        return this;
      }
      
      public bool HasDirection {
       get { return result.hasDirection; }
      }
      public global::Mysqlx.Crud.Order.Types.Direction Direction {
        get { return result.Direction; }
        set { SetDirection(value); }
      }
      public Builder SetDirection(global::Mysqlx.Crud.Order.Types.Direction value) {
        PrepareBuilder();
        result.hasDirection = true;
        result.direction_ = value;
        return this;
      }
      public Builder ClearDirection() {
        PrepareBuilder();
        result.hasDirection = false;
        result.direction_ = global::Mysqlx.Crud.Order.Types.Direction.ASC;
        return this;
      }
    }
    static Order() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class UpdateOperation : pb::GeneratedMessage<UpdateOperation, UpdateOperation.Builder> {
    private UpdateOperation() { }
    private static readonly UpdateOperation defaultInstance = new UpdateOperation().MakeReadOnly();
    private static readonly string[] _updateOperationFieldNames = new string[] { "operation", "source", "value" };
    private static readonly uint[] _updateOperationFieldTags = new uint[] { 16, 10, 26 };
    public static UpdateOperation DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override UpdateOperation DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override UpdateOperation ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_UpdateOperation__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<UpdateOperation, UpdateOperation.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_UpdateOperation__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum UpdateType {
        SET = 1,
        ITEM_REMOVE = 2,
        ITEM_SET = 3,
        ITEM_REPLACE = 4,
        ITEM_MERGE = 5,
        ARRAY_INSERT = 6,
        ARRAY_APPEND = 7,
      }
      
    }
    #endregion
    
    public const int SourceFieldNumber = 1;
    private bool hasSource;
    private global::Mysqlx.Expr.ColumnIdentifier source_;
    public bool HasSource {
      get { return hasSource; }
    }
    public global::Mysqlx.Expr.ColumnIdentifier Source {
      get { return source_ ?? global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance; }
    }
    
    public const int OperationFieldNumber = 2;
    private bool hasOperation;
    private global::Mysqlx.Crud.UpdateOperation.Types.UpdateType operation_ = global::Mysqlx.Crud.UpdateOperation.Types.UpdateType.SET;
    public bool HasOperation {
      get { return hasOperation; }
    }
    public global::Mysqlx.Crud.UpdateOperation.Types.UpdateType Operation {
      get { return operation_; }
    }
    
    public const int ValueFieldNumber = 3;
    private bool hasValue;
    private global::Mysqlx.Expr.Expr value_;
    public bool HasValue {
      get { return hasValue; }
    }
    public global::Mysqlx.Expr.Expr Value {
      get { return value_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSource) return false;
        if (!hasOperation) return false;
        if (!Source.IsInitialized) return false;
        if (HasValue) {
          if (!Value.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _updateOperationFieldNames;
      if (hasSource) {
        output.WriteMessage(1, field_names[1], Source);
      }
      if (hasOperation) {
        output.WriteEnum(2, field_names[0], (int) Operation, Operation);
      }
      if (hasValue) {
        output.WriteMessage(3, field_names[2], Value);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSource) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Source);
      }
      if (hasOperation) {
        size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Operation);
      }
      if (hasValue) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Value);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static UpdateOperation ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UpdateOperation ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UpdateOperation ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UpdateOperation ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UpdateOperation ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UpdateOperation ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static UpdateOperation ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static UpdateOperation ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static UpdateOperation ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UpdateOperation ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private UpdateOperation MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(UpdateOperation prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<UpdateOperation, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(UpdateOperation cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private UpdateOperation result;
      
      private UpdateOperation PrepareBuilder() {
        if (resultIsReadOnly) {
          UpdateOperation original = result;
          result = new UpdateOperation();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override UpdateOperation MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.UpdateOperation.Descriptor; }
      }
      
      public override UpdateOperation DefaultInstanceForType {
        get { return global::Mysqlx.Crud.UpdateOperation.DefaultInstance; }
      }
      
      public override UpdateOperation BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is UpdateOperation) {
          return MergeFrom((UpdateOperation) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(UpdateOperation other) {
        if (other == global::Mysqlx.Crud.UpdateOperation.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSource) {
          MergeSource(other.Source);
        }
        if (other.HasOperation) {
          Operation = other.Operation;
        }
        if (other.HasValue) {
          MergeValue(other.Value);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_updateOperationFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _updateOperationFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Expr.ColumnIdentifier.Builder subBuilder = global::Mysqlx.Expr.ColumnIdentifier.CreateBuilder();
              if (result.hasSource) {
                subBuilder.MergeFrom(Source);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Source = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.operation_, out unknown)) {
                result.hasOperation = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasValue) {
                subBuilder.MergeFrom(Value);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Value = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSource {
       get { return result.hasSource; }
      }
      public global::Mysqlx.Expr.ColumnIdentifier Source {
        get { return result.Source; }
        set { SetSource(value); }
      }
      public Builder SetSource(global::Mysqlx.Expr.ColumnIdentifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSource = true;
        result.source_ = value;
        return this;
      }
      public Builder SetSource(global::Mysqlx.Expr.ColumnIdentifier.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSource = true;
        result.source_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSource(global::Mysqlx.Expr.ColumnIdentifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSource &&
            result.source_ != global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance) {
            result.source_ = global::Mysqlx.Expr.ColumnIdentifier.CreateBuilder(result.source_).MergeFrom(value).BuildPartial();
        } else {
          result.source_ = value;
        }
        result.hasSource = true;
        return this;
      }
      public Builder ClearSource() {
        PrepareBuilder();
        result.hasSource = false;
        result.source_ = null;
        return this;
      }
      
      public bool HasOperation {
       get { return result.hasOperation; }
      }
      public global::Mysqlx.Crud.UpdateOperation.Types.UpdateType Operation {
        get { return result.Operation; }
        set { SetOperation(value); }
      }
      public Builder SetOperation(global::Mysqlx.Crud.UpdateOperation.Types.UpdateType value) {
        PrepareBuilder();
        result.hasOperation = true;
        result.operation_ = value;
        return this;
      }
      public Builder ClearOperation() {
        PrepareBuilder();
        result.hasOperation = false;
        result.operation_ = global::Mysqlx.Crud.UpdateOperation.Types.UpdateType.SET;
        return this;
      }
      
      public bool HasValue {
       get { return result.hasValue; }
      }
      public global::Mysqlx.Expr.Expr Value {
        get { return result.Value; }
        set { SetValue(value); }
      }
      public Builder SetValue(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = value;
        return this;
      }
      public Builder SetValue(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = builderForValue.Build();
        return this;
      }
      public Builder MergeValue(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasValue &&
            result.value_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.value_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.value_).MergeFrom(value).BuildPartial();
        } else {
          result.value_ = value;
        }
        result.hasValue = true;
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.hasValue = false;
        result.value_ = null;
        return this;
      }
    }
    static UpdateOperation() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Find : pb::GeneratedMessage<Find, Find.Builder> {
    private Find() { }
    private static readonly Find defaultInstance = new Find().MakeReadOnly();
    private static readonly string[] _findFieldNames = new string[] { "args", "collection", "criteria", "data_model", "grouping", "grouping_criteria", "limit", "order", "projection" };
    private static readonly uint[] _findFieldTags = new uint[] { 90, 18, 42, 24, 66, 74, 50, 58, 34 };
    public static Find DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Find DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Find ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Find__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Find, Find.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Find__FieldAccessorTable; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int ProjectionFieldNumber = 4;
    private pbc::PopsicleList<global::Mysqlx.Crud.Projection> projection_ = new pbc::PopsicleList<global::Mysqlx.Crud.Projection>();
    public scg::IList<global::Mysqlx.Crud.Projection> ProjectionList {
      get { return projection_; }
    }
    public int ProjectionCount {
      get { return projection_.Count; }
    }
    public global::Mysqlx.Crud.Projection GetProjection(int index) {
      return projection_[index];
    }
    
    public const int CriteriaFieldNumber = 5;
    private bool hasCriteria;
    private global::Mysqlx.Expr.Expr criteria_;
    public bool HasCriteria {
      get { return hasCriteria; }
    }
    public global::Mysqlx.Expr.Expr Criteria {
      get { return criteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int ArgsFieldNumber = 11;
    private pbc::PopsicleList<global::Mysqlx.Datatypes.Scalar> args_ = new pbc::PopsicleList<global::Mysqlx.Datatypes.Scalar>();
    public scg::IList<global::Mysqlx.Datatypes.Scalar> ArgsList {
      get { return args_; }
    }
    public int ArgsCount {
      get { return args_.Count; }
    }
    public global::Mysqlx.Datatypes.Scalar GetArgs(int index) {
      return args_[index];
    }
    
    public const int LimitFieldNumber = 6;
    private bool hasLimit;
    private global::Mysqlx.Crud.Limit limit_;
    public bool HasLimit {
      get { return hasLimit; }
    }
    public global::Mysqlx.Crud.Limit Limit {
      get { return limit_ ?? global::Mysqlx.Crud.Limit.DefaultInstance; }
    }
    
    public const int OrderFieldNumber = 7;
    private pbc::PopsicleList<global::Mysqlx.Crud.Order> order_ = new pbc::PopsicleList<global::Mysqlx.Crud.Order>();
    public scg::IList<global::Mysqlx.Crud.Order> OrderList {
      get { return order_; }
    }
    public int OrderCount {
      get { return order_.Count; }
    }
    public global::Mysqlx.Crud.Order GetOrder(int index) {
      return order_[index];
    }
    
    public const int GroupingFieldNumber = 8;
    private pbc::PopsicleList<global::Mysqlx.Expr.Expr> grouping_ = new pbc::PopsicleList<global::Mysqlx.Expr.Expr>();
    public scg::IList<global::Mysqlx.Expr.Expr> GroupingList {
      get { return grouping_; }
    }
    public int GroupingCount {
      get { return grouping_.Count; }
    }
    public global::Mysqlx.Expr.Expr GetGrouping(int index) {
      return grouping_[index];
    }
    
    public const int GroupingCriteriaFieldNumber = 9;
    private bool hasGroupingCriteria;
    private global::Mysqlx.Expr.Expr groupingCriteria_;
    public bool HasGroupingCriteria {
      get { return hasGroupingCriteria; }
    }
    public global::Mysqlx.Expr.Expr GroupingCriteria {
      get { return groupingCriteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        foreach (global::Mysqlx.Crud.Projection element in ProjectionList) {
          if (!element.IsInitialized) return false;
        }
        if (HasCriteria) {
          if (!Criteria.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Datatypes.Scalar element in ArgsList) {
          if (!element.IsInitialized) return false;
        }
        if (HasLimit) {
          if (!Limit.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Expr.Expr element in GroupingList) {
          if (!element.IsInitialized) return false;
        }
        if (HasGroupingCriteria) {
          if (!GroupingCriteria.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _findFieldNames;
      if (hasCollection) {
        output.WriteMessage(2, field_names[1], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[3], (int) DataModel, DataModel);
      }
      if (projection_.Count > 0) {
        output.WriteMessageArray(4, field_names[8], projection_);
      }
      if (hasCriteria) {
        output.WriteMessage(5, field_names[2], Criteria);
      }
      if (hasLimit) {
        output.WriteMessage(6, field_names[6], Limit);
      }
      if (order_.Count > 0) {
        output.WriteMessageArray(7, field_names[7], order_);
      }
      if (grouping_.Count > 0) {
        output.WriteMessageArray(8, field_names[4], grouping_);
      }
      if (hasGroupingCriteria) {
        output.WriteMessage(9, field_names[5], GroupingCriteria);
      }
      if (args_.Count > 0) {
        output.WriteMessageArray(11, field_names[0], args_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCollection) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
      }
      if (hasDataModel) {
        size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
      }
      foreach (global::Mysqlx.Crud.Projection element in ProjectionList) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, element);
      }
      if (hasCriteria) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, Criteria);
      }
      foreach (global::Mysqlx.Datatypes.Scalar element in ArgsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(11, element);
      }
      if (hasLimit) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, Limit);
      }
      foreach (global::Mysqlx.Crud.Order element in OrderList) {
        size += pb::CodedOutputStream.ComputeMessageSize(7, element);
      }
      foreach (global::Mysqlx.Expr.Expr element in GroupingList) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, element);
      }
      if (hasGroupingCriteria) {
        size += pb::CodedOutputStream.ComputeMessageSize(9, GroupingCriteria);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Find ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Find ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Find ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Find ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Find ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Find ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Find ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Find ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Find ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Find ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Find MakeReadOnly() {
      projection_.MakeReadOnly();
      args_.MakeReadOnly();
      order_.MakeReadOnly();
      grouping_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Find prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Find, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Find cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Find result;
      
      private Find PrepareBuilder() {
        if (resultIsReadOnly) {
          Find original = result;
          result = new Find();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Find MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Find.Descriptor; }
      }
      
      public override Find DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Find.DefaultInstance; }
      }
      
      public override Find BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Find) {
          return MergeFrom((Find) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Find other) {
        if (other == global::Mysqlx.Crud.Find.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.projection_.Count != 0) {
          result.projection_.Add(other.projection_);
        }
        if (other.HasCriteria) {
          MergeCriteria(other.Criteria);
        }
        if (other.args_.Count != 0) {
          result.args_.Add(other.args_);
        }
        if (other.HasLimit) {
          MergeLimit(other.Limit);
        }
        if (other.order_.Count != 0) {
          result.order_.Add(other.order_);
        }
        if (other.grouping_.Count != 0) {
          result.grouping_.Add(other.grouping_);
        }
        if (other.HasGroupingCriteria) {
          MergeGroupingCriteria(other.GroupingCriteria);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_findFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _findFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.projection_, global::Mysqlx.Crud.Projection.DefaultInstance, extensionRegistry);
              break;
            }
            case 42: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasCriteria) {
                subBuilder.MergeFrom(Criteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Criteria = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::Mysqlx.Crud.Limit.Builder subBuilder = global::Mysqlx.Crud.Limit.CreateBuilder();
              if (result.hasLimit) {
                subBuilder.MergeFrom(Limit);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Limit = subBuilder.BuildPartial();
              break;
            }
            case 58: {
              input.ReadMessageArray(tag, field_name, result.order_, global::Mysqlx.Crud.Order.DefaultInstance, extensionRegistry);
              break;
            }
            case 66: {
              input.ReadMessageArray(tag, field_name, result.grouping_, global::Mysqlx.Expr.Expr.DefaultInstance, extensionRegistry);
              break;
            }
            case 74: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasGroupingCriteria) {
                subBuilder.MergeFrom(GroupingCriteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              GroupingCriteria = subBuilder.BuildPartial();
              break;
            }
            case 90: {
              input.ReadMessageArray(tag, field_name, result.args_, global::Mysqlx.Datatypes.Scalar.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Projection> ProjectionList {
        get { return PrepareBuilder().projection_; }
      }
      public int ProjectionCount {
        get { return result.ProjectionCount; }
      }
      public global::Mysqlx.Crud.Projection GetProjection(int index) {
        return result.GetProjection(index);
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Projection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_[index] = value;
        return this;
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Projection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Projection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_.Add(value);
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Projection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProjection(scg::IEnumerable<global::Mysqlx.Crud.Projection> values) {
        PrepareBuilder();
        result.projection_.Add(values);
        return this;
      }
      public Builder ClearProjection() {
        PrepareBuilder();
        result.projection_.Clear();
        return this;
      }
      
      public bool HasCriteria {
       get { return result.hasCriteria; }
      }
      public global::Mysqlx.Expr.Expr Criteria {
        get { return result.Criteria; }
        set { SetCriteria(value); }
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = value;
        return this;
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCriteria &&
            result.criteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.criteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.criteria_).MergeFrom(value).BuildPartial();
        } else {
          result.criteria_ = value;
        }
        result.hasCriteria = true;
        return this;
      }
      public Builder ClearCriteria() {
        PrepareBuilder();
        result.hasCriteria = false;
        result.criteria_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Datatypes.Scalar> ArgsList {
        get { return PrepareBuilder().args_; }
      }
      public int ArgsCount {
        get { return result.ArgsCount; }
      }
      public global::Mysqlx.Datatypes.Scalar GetArgs(int index) {
        return result.GetArgs(index);
      }
      public Builder SetArgs(int index, global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.args_[index] = value;
        return this;
      }
      public Builder SetArgs(int index, global::Mysqlx.Datatypes.Scalar.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.args_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddArgs(global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.args_.Add(value);
        return this;
      }
      public Builder AddArgs(global::Mysqlx.Datatypes.Scalar.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.args_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeArgs(scg::IEnumerable<global::Mysqlx.Datatypes.Scalar> values) {
        PrepareBuilder();
        result.args_.Add(values);
        return this;
      }
      public Builder ClearArgs() {
        PrepareBuilder();
        result.args_.Clear();
        return this;
      }
      
      public bool HasLimit {
       get { return result.hasLimit; }
      }
      public global::Mysqlx.Crud.Limit Limit {
        get { return result.Limit; }
        set { SetLimit(value); }
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = value;
        return this;
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLimit &&
            result.limit_ != global::Mysqlx.Crud.Limit.DefaultInstance) {
            result.limit_ = global::Mysqlx.Crud.Limit.CreateBuilder(result.limit_).MergeFrom(value).BuildPartial();
        } else {
          result.limit_ = value;
        }
        result.hasLimit = true;
        return this;
      }
      public Builder ClearLimit() {
        PrepareBuilder();
        result.hasLimit = false;
        result.limit_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Order> OrderList {
        get { return PrepareBuilder().order_; }
      }
      public int OrderCount {
        get { return result.OrderCount; }
      }
      public global::Mysqlx.Crud.Order GetOrder(int index) {
        return result.GetOrder(index);
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_[index] = value;
        return this;
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_.Add(value);
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOrder(scg::IEnumerable<global::Mysqlx.Crud.Order> values) {
        PrepareBuilder();
        result.order_.Add(values);
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.order_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.Expr> GroupingList {
        get { return PrepareBuilder().grouping_; }
      }
      public int GroupingCount {
        get { return result.GroupingCount; }
      }
      public global::Mysqlx.Expr.Expr GetGrouping(int index) {
        return result.GetGrouping(index);
      }
      public Builder SetGrouping(int index, global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.grouping_[index] = value;
        return this;
      }
      public Builder SetGrouping(int index, global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.grouping_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddGrouping(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.grouping_.Add(value);
        return this;
      }
      public Builder AddGrouping(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.grouping_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeGrouping(scg::IEnumerable<global::Mysqlx.Expr.Expr> values) {
        PrepareBuilder();
        result.grouping_.Add(values);
        return this;
      }
      public Builder ClearGrouping() {
        PrepareBuilder();
        result.grouping_.Clear();
        return this;
      }
      
      public bool HasGroupingCriteria {
       get { return result.hasGroupingCriteria; }
      }
      public global::Mysqlx.Expr.Expr GroupingCriteria {
        get { return result.GroupingCriteria; }
        set { SetGroupingCriteria(value); }
      }
      public Builder SetGroupingCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGroupingCriteria = true;
        result.groupingCriteria_ = value;
        return this;
      }
      public Builder SetGroupingCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGroupingCriteria = true;
        result.groupingCriteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGroupingCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGroupingCriteria &&
            result.groupingCriteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.groupingCriteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.groupingCriteria_).MergeFrom(value).BuildPartial();
        } else {
          result.groupingCriteria_ = value;
        }
        result.hasGroupingCriteria = true;
        return this;
      }
      public Builder ClearGroupingCriteria() {
        PrepareBuilder();
        result.hasGroupingCriteria = false;
        result.groupingCriteria_ = null;
        return this;
      }
    }
    static Find() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Insert : pb::GeneratedMessage<Insert, Insert.Builder> {
    private Insert() { }
    private static readonly Insert defaultInstance = new Insert().MakeReadOnly();
    private static readonly string[] _insertFieldNames = new string[] { "collection", "data_model", "projection", "row" };
    private static readonly uint[] _insertFieldTags = new uint[] { 10, 16, 26, 34 };
    public static Insert DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Insert DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Insert ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Insert__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Insert, Insert.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Insert__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class TypedRow : pb::GeneratedMessage<TypedRow, TypedRow.Builder> {
        private TypedRow() { }
        private static readonly TypedRow defaultInstance = new TypedRow().MakeReadOnly();
        private static readonly string[] _typedRowFieldNames = new string[] { "field" };
        private static readonly uint[] _typedRowFieldTags = new uint[] { 10 };
        public static TypedRow DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override TypedRow DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override TypedRow ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Insert_TypedRow__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<TypedRow, TypedRow.Builder> InternalFieldAccessors {
          get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Insert_TypedRow__FieldAccessorTable; }
        }
        
        public const int FieldFieldNumber = 1;
        private pbc::PopsicleList<global::Mysqlx.Expr.Expr> field_ = new pbc::PopsicleList<global::Mysqlx.Expr.Expr>();
        public scg::IList<global::Mysqlx.Expr.Expr> FieldList {
          get { return field_; }
        }
        public int FieldCount {
          get { return field_.Count; }
        }
        public global::Mysqlx.Expr.Expr GetField(int index) {
          return field_[index];
        }
        
        public override bool IsInitialized {
          get {
            foreach (global::Mysqlx.Expr.Expr element in FieldList) {
              if (!element.IsInitialized) return false;
            }
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _typedRowFieldNames;
          if (field_.Count > 0) {
            output.WriteMessageArray(1, field_names[0], field_);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          foreach (global::Mysqlx.Expr.Expr element in FieldList) {
            size += pb::CodedOutputStream.ComputeMessageSize(1, element);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
        public static TypedRow ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TypedRow ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TypedRow ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TypedRow ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TypedRow ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TypedRow ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static TypedRow ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static TypedRow ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static TypedRow ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TypedRow ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private TypedRow MakeReadOnly() {
          field_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(TypedRow prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<TypedRow, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(TypedRow cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private TypedRow result;
          
          private TypedRow PrepareBuilder() {
            if (resultIsReadOnly) {
              TypedRow original = result;
              result = new TypedRow();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override TypedRow MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::Mysqlx.Crud.Insert.Types.TypedRow.Descriptor; }
          }
          
          public override TypedRow DefaultInstanceForType {
            get { return global::Mysqlx.Crud.Insert.Types.TypedRow.DefaultInstance; }
          }
          
          public override TypedRow BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is TypedRow) {
              return MergeFrom((TypedRow) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(TypedRow other) {
            if (other == global::Mysqlx.Crud.Insert.Types.TypedRow.DefaultInstance) return this;
            PrepareBuilder();
            if (other.field_.Count != 0) {
              result.field_.Add(other.field_);
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_typedRowFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _typedRowFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  input.ReadMessageArray(tag, field_name, result.field_, global::Mysqlx.Expr.Expr.DefaultInstance, extensionRegistry);
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public pbc::IPopsicleList<global::Mysqlx.Expr.Expr> FieldList {
            get { return PrepareBuilder().field_; }
          }
          public int FieldCount {
            get { return result.FieldCount; }
          }
          public global::Mysqlx.Expr.Expr GetField(int index) {
            return result.GetField(index);
          }
          public Builder SetField(int index, global::Mysqlx.Expr.Expr value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.field_[index] = value;
            return this;
          }
          public Builder SetField(int index, global::Mysqlx.Expr.Expr.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.field_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddField(global::Mysqlx.Expr.Expr value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.field_.Add(value);
            return this;
          }
          public Builder AddField(global::Mysqlx.Expr.Expr.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.field_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeField(scg::IEnumerable<global::Mysqlx.Expr.Expr> values) {
            PrepareBuilder();
            result.field_.Add(values);
            return this;
          }
          public Builder ClearField() {
            PrepareBuilder();
            result.field_.Clear();
            return this;
          }
        }
        static TypedRow() {
          object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public const int CollectionFieldNumber = 1;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 2;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int ProjectionFieldNumber = 3;
    private pbc::PopsicleList<global::Mysqlx.Crud.Column> projection_ = new pbc::PopsicleList<global::Mysqlx.Crud.Column>();
    public scg::IList<global::Mysqlx.Crud.Column> ProjectionList {
      get { return projection_; }
    }
    public int ProjectionCount {
      get { return projection_.Count; }
    }
    public global::Mysqlx.Crud.Column GetProjection(int index) {
      return projection_[index];
    }
    
    public const int RowFieldNumber = 4;
    private pbc::PopsicleList<global::Mysqlx.Crud.Insert.Types.TypedRow> row_ = new pbc::PopsicleList<global::Mysqlx.Crud.Insert.Types.TypedRow>();
    public scg::IList<global::Mysqlx.Crud.Insert.Types.TypedRow> RowList {
      get { return row_; }
    }
    public int RowCount {
      get { return row_.Count; }
    }
    public global::Mysqlx.Crud.Insert.Types.TypedRow GetRow(int index) {
      return row_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Insert.Types.TypedRow element in RowList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _insertFieldNames;
      if (hasCollection) {
        output.WriteMessage(1, field_names[0], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(2, field_names[1], (int) DataModel, DataModel);
      }
      if (projection_.Count > 0) {
        output.WriteMessageArray(3, field_names[2], projection_);
      }
      if (row_.Count > 0) {
        output.WriteMessageArray(4, field_names[3], row_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCollection) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Collection);
      }
      if (hasDataModel) {
        size += pb::CodedOutputStream.ComputeEnumSize(2, (int) DataModel);
      }
      foreach (global::Mysqlx.Crud.Column element in ProjectionList) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      foreach (global::Mysqlx.Crud.Insert.Types.TypedRow element in RowList) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Insert ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Insert ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Insert ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Insert ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Insert ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Insert ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Insert ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Insert ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Insert ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Insert ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Insert MakeReadOnly() {
      projection_.MakeReadOnly();
      row_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Insert prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Insert, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Insert cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Insert result;
      
      private Insert PrepareBuilder() {
        if (resultIsReadOnly) {
          Insert original = result;
          result = new Insert();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Insert MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Insert.Descriptor; }
      }
      
      public override Insert DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Insert.DefaultInstance; }
      }
      
      public override Insert BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Insert) {
          return MergeFrom((Insert) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Insert other) {
        if (other == global::Mysqlx.Crud.Insert.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.projection_.Count != 0) {
          result.projection_.Add(other.projection_);
        }
        if (other.row_.Count != 0) {
          result.row_.Add(other.row_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_insertFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _insertFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.projection_, global::Mysqlx.Crud.Column.DefaultInstance, extensionRegistry);
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.row_, global::Mysqlx.Crud.Insert.Types.TypedRow.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Column> ProjectionList {
        get { return PrepareBuilder().projection_; }
      }
      public int ProjectionCount {
        get { return result.ProjectionCount; }
      }
      public global::Mysqlx.Crud.Column GetProjection(int index) {
        return result.GetProjection(index);
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_[index] = value;
        return this;
      }
      public Builder SetProjection(int index, global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.projection_.Add(value);
        return this;
      }
      public Builder AddProjection(global::Mysqlx.Crud.Column.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.projection_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProjection(scg::IEnumerable<global::Mysqlx.Crud.Column> values) {
        PrepareBuilder();
        result.projection_.Add(values);
        return this;
      }
      public Builder ClearProjection() {
        PrepareBuilder();
        result.projection_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Insert.Types.TypedRow> RowList {
        get { return PrepareBuilder().row_; }
      }
      public int RowCount {
        get { return result.RowCount; }
      }
      public global::Mysqlx.Crud.Insert.Types.TypedRow GetRow(int index) {
        return result.GetRow(index);
      }
      public Builder SetRow(int index, global::Mysqlx.Crud.Insert.Types.TypedRow value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.row_[index] = value;
        return this;
      }
      public Builder SetRow(int index, global::Mysqlx.Crud.Insert.Types.TypedRow.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.row_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRow(global::Mysqlx.Crud.Insert.Types.TypedRow value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.row_.Add(value);
        return this;
      }
      public Builder AddRow(global::Mysqlx.Crud.Insert.Types.TypedRow.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.row_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRow(scg::IEnumerable<global::Mysqlx.Crud.Insert.Types.TypedRow> values) {
        PrepareBuilder();
        result.row_.Add(values);
        return this;
      }
      public Builder ClearRow() {
        PrepareBuilder();
        result.row_.Clear();
        return this;
      }
    }
    static Insert() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Update : pb::GeneratedMessage<Update, Update.Builder> {
    private Update() { }
    private static readonly Update defaultInstance = new Update().MakeReadOnly();
    private static readonly string[] _updateFieldNames = new string[] { "args", "collection", "criteria", "data_model", "limit", "operation", "order" };
    private static readonly uint[] _updateFieldTags = new uint[] { 66, 18, 34, 24, 42, 58, 50 };
    public static Update DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Update DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Update ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Update__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Update, Update.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Update__FieldAccessorTable; }
    }
    
    public const int CollectionFieldNumber = 2;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 3;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int CriteriaFieldNumber = 4;
    private bool hasCriteria;
    private global::Mysqlx.Expr.Expr criteria_;
    public bool HasCriteria {
      get { return hasCriteria; }
    }
    public global::Mysqlx.Expr.Expr Criteria {
      get { return criteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int ArgsFieldNumber = 8;
    private pbc::PopsicleList<global::Mysqlx.Datatypes.Scalar> args_ = new pbc::PopsicleList<global::Mysqlx.Datatypes.Scalar>();
    public scg::IList<global::Mysqlx.Datatypes.Scalar> ArgsList {
      get { return args_; }
    }
    public int ArgsCount {
      get { return args_.Count; }
    }
    public global::Mysqlx.Datatypes.Scalar GetArgs(int index) {
      return args_[index];
    }
    
    public const int LimitFieldNumber = 5;
    private bool hasLimit;
    private global::Mysqlx.Crud.Limit limit_;
    public bool HasLimit {
      get { return hasLimit; }
    }
    public global::Mysqlx.Crud.Limit Limit {
      get { return limit_ ?? global::Mysqlx.Crud.Limit.DefaultInstance; }
    }
    
    public const int OrderFieldNumber = 6;
    private pbc::PopsicleList<global::Mysqlx.Crud.Order> order_ = new pbc::PopsicleList<global::Mysqlx.Crud.Order>();
    public scg::IList<global::Mysqlx.Crud.Order> OrderList {
      get { return order_; }
    }
    public int OrderCount {
      get { return order_.Count; }
    }
    public global::Mysqlx.Crud.Order GetOrder(int index) {
      return order_[index];
    }
    
    public const int OperationFieldNumber = 7;
    private pbc::PopsicleList<global::Mysqlx.Crud.UpdateOperation> operation_ = new pbc::PopsicleList<global::Mysqlx.Crud.UpdateOperation>();
    public scg::IList<global::Mysqlx.Crud.UpdateOperation> OperationList {
      get { return operation_; }
    }
    public int OperationCount {
      get { return operation_.Count; }
    }
    public global::Mysqlx.Crud.UpdateOperation GetOperation(int index) {
      return operation_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        if (HasCriteria) {
          if (!Criteria.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Datatypes.Scalar element in ArgsList) {
          if (!element.IsInitialized) return false;
        }
        if (HasLimit) {
          if (!Limit.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.UpdateOperation element in OperationList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _updateFieldNames;
      if (hasCollection) {
        output.WriteMessage(2, field_names[1], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(3, field_names[3], (int) DataModel, DataModel);
      }
      if (hasCriteria) {
        output.WriteMessage(4, field_names[2], Criteria);
      }
      if (hasLimit) {
        output.WriteMessage(5, field_names[4], Limit);
      }
      if (order_.Count > 0) {
        output.WriteMessageArray(6, field_names[6], order_);
      }
      if (operation_.Count > 0) {
        output.WriteMessageArray(7, field_names[5], operation_);
      }
      if (args_.Count > 0) {
        output.WriteMessageArray(8, field_names[0], args_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCollection) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Collection);
      }
      if (hasDataModel) {
        size += pb::CodedOutputStream.ComputeEnumSize(3, (int) DataModel);
      }
      if (hasCriteria) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, Criteria);
      }
      foreach (global::Mysqlx.Datatypes.Scalar element in ArgsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, element);
      }
      if (hasLimit) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, Limit);
      }
      foreach (global::Mysqlx.Crud.Order element in OrderList) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, element);
      }
      foreach (global::Mysqlx.Crud.UpdateOperation element in OperationList) {
        size += pb::CodedOutputStream.ComputeMessageSize(7, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Update ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Update ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Update ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Update ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Update ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Update ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Update ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Update ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Update ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Update ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Update MakeReadOnly() {
      args_.MakeReadOnly();
      order_.MakeReadOnly();
      operation_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Update prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Update, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Update cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Update result;
      
      private Update PrepareBuilder() {
        if (resultIsReadOnly) {
          Update original = result;
          result = new Update();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Update MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Update.Descriptor; }
      }
      
      public override Update DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Update.DefaultInstance; }
      }
      
      public override Update BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Update) {
          return MergeFrom((Update) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Update other) {
        if (other == global::Mysqlx.Crud.Update.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.HasCriteria) {
          MergeCriteria(other.Criteria);
        }
        if (other.args_.Count != 0) {
          result.args_.Add(other.args_);
        }
        if (other.HasLimit) {
          MergeLimit(other.Limit);
        }
        if (other.order_.Count != 0) {
          result.order_.Add(other.order_);
        }
        if (other.operation_.Count != 0) {
          result.operation_.Add(other.operation_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_updateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _updateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 18: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasCriteria) {
                subBuilder.MergeFrom(Criteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Criteria = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::Mysqlx.Crud.Limit.Builder subBuilder = global::Mysqlx.Crud.Limit.CreateBuilder();
              if (result.hasLimit) {
                subBuilder.MergeFrom(Limit);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Limit = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              input.ReadMessageArray(tag, field_name, result.order_, global::Mysqlx.Crud.Order.DefaultInstance, extensionRegistry);
              break;
            }
            case 58: {
              input.ReadMessageArray(tag, field_name, result.operation_, global::Mysqlx.Crud.UpdateOperation.DefaultInstance, extensionRegistry);
              break;
            }
            case 66: {
              input.ReadMessageArray(tag, field_name, result.args_, global::Mysqlx.Datatypes.Scalar.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public bool HasCriteria {
       get { return result.hasCriteria; }
      }
      public global::Mysqlx.Expr.Expr Criteria {
        get { return result.Criteria; }
        set { SetCriteria(value); }
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = value;
        return this;
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCriteria &&
            result.criteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.criteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.criteria_).MergeFrom(value).BuildPartial();
        } else {
          result.criteria_ = value;
        }
        result.hasCriteria = true;
        return this;
      }
      public Builder ClearCriteria() {
        PrepareBuilder();
        result.hasCriteria = false;
        result.criteria_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Datatypes.Scalar> ArgsList {
        get { return PrepareBuilder().args_; }
      }
      public int ArgsCount {
        get { return result.ArgsCount; }
      }
      public global::Mysqlx.Datatypes.Scalar GetArgs(int index) {
        return result.GetArgs(index);
      }
      public Builder SetArgs(int index, global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.args_[index] = value;
        return this;
      }
      public Builder SetArgs(int index, global::Mysqlx.Datatypes.Scalar.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.args_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddArgs(global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.args_.Add(value);
        return this;
      }
      public Builder AddArgs(global::Mysqlx.Datatypes.Scalar.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.args_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeArgs(scg::IEnumerable<global::Mysqlx.Datatypes.Scalar> values) {
        PrepareBuilder();
        result.args_.Add(values);
        return this;
      }
      public Builder ClearArgs() {
        PrepareBuilder();
        result.args_.Clear();
        return this;
      }
      
      public bool HasLimit {
       get { return result.hasLimit; }
      }
      public global::Mysqlx.Crud.Limit Limit {
        get { return result.Limit; }
        set { SetLimit(value); }
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = value;
        return this;
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLimit &&
            result.limit_ != global::Mysqlx.Crud.Limit.DefaultInstance) {
            result.limit_ = global::Mysqlx.Crud.Limit.CreateBuilder(result.limit_).MergeFrom(value).BuildPartial();
        } else {
          result.limit_ = value;
        }
        result.hasLimit = true;
        return this;
      }
      public Builder ClearLimit() {
        PrepareBuilder();
        result.hasLimit = false;
        result.limit_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Order> OrderList {
        get { return PrepareBuilder().order_; }
      }
      public int OrderCount {
        get { return result.OrderCount; }
      }
      public global::Mysqlx.Crud.Order GetOrder(int index) {
        return result.GetOrder(index);
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_[index] = value;
        return this;
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_.Add(value);
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOrder(scg::IEnumerable<global::Mysqlx.Crud.Order> values) {
        PrepareBuilder();
        result.order_.Add(values);
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.order_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.UpdateOperation> OperationList {
        get { return PrepareBuilder().operation_; }
      }
      public int OperationCount {
        get { return result.OperationCount; }
      }
      public global::Mysqlx.Crud.UpdateOperation GetOperation(int index) {
        return result.GetOperation(index);
      }
      public Builder SetOperation(int index, global::Mysqlx.Crud.UpdateOperation value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.operation_[index] = value;
        return this;
      }
      public Builder SetOperation(int index, global::Mysqlx.Crud.UpdateOperation.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.operation_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOperation(global::Mysqlx.Crud.UpdateOperation value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.operation_.Add(value);
        return this;
      }
      public Builder AddOperation(global::Mysqlx.Crud.UpdateOperation.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.operation_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOperation(scg::IEnumerable<global::Mysqlx.Crud.UpdateOperation> values) {
        PrepareBuilder();
        result.operation_.Add(values);
        return this;
      }
      public Builder ClearOperation() {
        PrepareBuilder();
        result.operation_.Clear();
        return this;
      }
    }
    static Update() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Delete : pb::GeneratedMessage<Delete, Delete.Builder> {
    private Delete() { }
    private static readonly Delete defaultInstance = new Delete().MakeReadOnly();
    private static readonly string[] _deleteFieldNames = new string[] { "args", "collection", "criteria", "data_model", "limit", "order" };
    private static readonly uint[] _deleteFieldTags = new uint[] { 50, 10, 26, 16, 34, 42 };
    public static Delete DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Delete DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Delete ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Delete__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Delete, Delete.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Crud.MysqlxCrud.internal__static_Mysqlx_Crud_Delete__FieldAccessorTable; }
    }
    
    public const int CollectionFieldNumber = 1;
    private bool hasCollection;
    private global::Mysqlx.Crud.Collection collection_;
    public bool HasCollection {
      get { return hasCollection; }
    }
    public global::Mysqlx.Crud.Collection Collection {
      get { return collection_ ?? global::Mysqlx.Crud.Collection.DefaultInstance; }
    }
    
    public const int DataModelFieldNumber = 2;
    private bool hasDataModel;
    private global::Mysqlx.Crud.DataModel dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
    public bool HasDataModel {
      get { return hasDataModel; }
    }
    public global::Mysqlx.Crud.DataModel DataModel {
      get { return dataModel_; }
    }
    
    public const int CriteriaFieldNumber = 3;
    private bool hasCriteria;
    private global::Mysqlx.Expr.Expr criteria_;
    public bool HasCriteria {
      get { return hasCriteria; }
    }
    public global::Mysqlx.Expr.Expr Criteria {
      get { return criteria_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
    }
    
    public const int ArgsFieldNumber = 6;
    private pbc::PopsicleList<global::Mysqlx.Datatypes.Scalar> args_ = new pbc::PopsicleList<global::Mysqlx.Datatypes.Scalar>();
    public scg::IList<global::Mysqlx.Datatypes.Scalar> ArgsList {
      get { return args_; }
    }
    public int ArgsCount {
      get { return args_.Count; }
    }
    public global::Mysqlx.Datatypes.Scalar GetArgs(int index) {
      return args_[index];
    }
    
    public const int LimitFieldNumber = 4;
    private bool hasLimit;
    private global::Mysqlx.Crud.Limit limit_;
    public bool HasLimit {
      get { return hasLimit; }
    }
    public global::Mysqlx.Crud.Limit Limit {
      get { return limit_ ?? global::Mysqlx.Crud.Limit.DefaultInstance; }
    }
    
    public const int OrderFieldNumber = 5;
    private pbc::PopsicleList<global::Mysqlx.Crud.Order> order_ = new pbc::PopsicleList<global::Mysqlx.Crud.Order>();
    public scg::IList<global::Mysqlx.Crud.Order> OrderList {
      get { return order_; }
    }
    public int OrderCount {
      get { return order_.Count; }
    }
    public global::Mysqlx.Crud.Order GetOrder(int index) {
      return order_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCollection) return false;
        if (!Collection.IsInitialized) return false;
        if (HasCriteria) {
          if (!Criteria.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Datatypes.Scalar element in ArgsList) {
          if (!element.IsInitialized) return false;
        }
        if (HasLimit) {
          if (!Limit.IsInitialized) return false;
        }
        foreach (global::Mysqlx.Crud.Order element in OrderList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _deleteFieldNames;
      if (hasCollection) {
        output.WriteMessage(1, field_names[1], Collection);
      }
      if (hasDataModel) {
        output.WriteEnum(2, field_names[3], (int) DataModel, DataModel);
      }
      if (hasCriteria) {
        output.WriteMessage(3, field_names[2], Criteria);
      }
      if (hasLimit) {
        output.WriteMessage(4, field_names[4], Limit);
      }
      if (order_.Count > 0) {
        output.WriteMessageArray(5, field_names[5], order_);
      }
      if (args_.Count > 0) {
        output.WriteMessageArray(6, field_names[0], args_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCollection) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Collection);
      }
      if (hasDataModel) {
        size += pb::CodedOutputStream.ComputeEnumSize(2, (int) DataModel);
      }
      if (hasCriteria) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Criteria);
      }
      foreach (global::Mysqlx.Datatypes.Scalar element in ArgsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, element);
      }
      if (hasLimit) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, Limit);
      }
      foreach (global::Mysqlx.Crud.Order element in OrderList) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Delete ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Delete ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Delete ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Delete ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Delete ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Delete ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Delete ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Delete ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Delete ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Delete ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Delete MakeReadOnly() {
      args_.MakeReadOnly();
      order_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Delete prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Delete, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Delete cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Delete result;
      
      private Delete PrepareBuilder() {
        if (resultIsReadOnly) {
          Delete original = result;
          result = new Delete();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Delete MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Crud.Delete.Descriptor; }
      }
      
      public override Delete DefaultInstanceForType {
        get { return global::Mysqlx.Crud.Delete.DefaultInstance; }
      }
      
      public override Delete BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Delete) {
          return MergeFrom((Delete) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Delete other) {
        if (other == global::Mysqlx.Crud.Delete.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCollection) {
          MergeCollection(other.Collection);
        }
        if (other.HasDataModel) {
          DataModel = other.DataModel;
        }
        if (other.HasCriteria) {
          MergeCriteria(other.Criteria);
        }
        if (other.args_.Count != 0) {
          result.args_.Add(other.args_);
        }
        if (other.HasLimit) {
          MergeLimit(other.Limit);
        }
        if (other.order_.Count != 0) {
          result.order_.Add(other.order_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_deleteFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _deleteFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Crud.Collection.Builder subBuilder = global::Mysqlx.Crud.Collection.CreateBuilder();
              if (result.hasCollection) {
                subBuilder.MergeFrom(Collection);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Collection = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.dataModel_, out unknown)) {
                result.hasDataModel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 26: {
              global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
              if (result.hasCriteria) {
                subBuilder.MergeFrom(Criteria);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Criteria = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::Mysqlx.Crud.Limit.Builder subBuilder = global::Mysqlx.Crud.Limit.CreateBuilder();
              if (result.hasLimit) {
                subBuilder.MergeFrom(Limit);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Limit = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              input.ReadMessageArray(tag, field_name, result.order_, global::Mysqlx.Crud.Order.DefaultInstance, extensionRegistry);
              break;
            }
            case 50: {
              input.ReadMessageArray(tag, field_name, result.args_, global::Mysqlx.Datatypes.Scalar.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCollection {
       get { return result.hasCollection; }
      }
      public global::Mysqlx.Crud.Collection Collection {
        get { return result.Collection; }
        set { SetCollection(value); }
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = value;
        return this;
      }
      public Builder SetCollection(global::Mysqlx.Crud.Collection.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCollection = true;
        result.collection_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCollection(global::Mysqlx.Crud.Collection value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCollection &&
            result.collection_ != global::Mysqlx.Crud.Collection.DefaultInstance) {
            result.collection_ = global::Mysqlx.Crud.Collection.CreateBuilder(result.collection_).MergeFrom(value).BuildPartial();
        } else {
          result.collection_ = value;
        }
        result.hasCollection = true;
        return this;
      }
      public Builder ClearCollection() {
        PrepareBuilder();
        result.hasCollection = false;
        result.collection_ = null;
        return this;
      }
      
      public bool HasDataModel {
       get { return result.hasDataModel; }
      }
      public global::Mysqlx.Crud.DataModel DataModel {
        get { return result.DataModel; }
        set { SetDataModel(value); }
      }
      public Builder SetDataModel(global::Mysqlx.Crud.DataModel value) {
        PrepareBuilder();
        result.hasDataModel = true;
        result.dataModel_ = value;
        return this;
      }
      public Builder ClearDataModel() {
        PrepareBuilder();
        result.hasDataModel = false;
        result.dataModel_ = global::Mysqlx.Crud.DataModel.DOCUMENT;
        return this;
      }
      
      public bool HasCriteria {
       get { return result.hasCriteria; }
      }
      public global::Mysqlx.Expr.Expr Criteria {
        get { return result.Criteria; }
        set { SetCriteria(value); }
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = value;
        return this;
      }
      public Builder SetCriteria(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCriteria = true;
        result.criteria_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCriteria(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCriteria &&
            result.criteria_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
            result.criteria_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.criteria_).MergeFrom(value).BuildPartial();
        } else {
          result.criteria_ = value;
        }
        result.hasCriteria = true;
        return this;
      }
      public Builder ClearCriteria() {
        PrepareBuilder();
        result.hasCriteria = false;
        result.criteria_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Datatypes.Scalar> ArgsList {
        get { return PrepareBuilder().args_; }
      }
      public int ArgsCount {
        get { return result.ArgsCount; }
      }
      public global::Mysqlx.Datatypes.Scalar GetArgs(int index) {
        return result.GetArgs(index);
      }
      public Builder SetArgs(int index, global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.args_[index] = value;
        return this;
      }
      public Builder SetArgs(int index, global::Mysqlx.Datatypes.Scalar.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.args_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddArgs(global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.args_.Add(value);
        return this;
      }
      public Builder AddArgs(global::Mysqlx.Datatypes.Scalar.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.args_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeArgs(scg::IEnumerable<global::Mysqlx.Datatypes.Scalar> values) {
        PrepareBuilder();
        result.args_.Add(values);
        return this;
      }
      public Builder ClearArgs() {
        PrepareBuilder();
        result.args_.Clear();
        return this;
      }
      
      public bool HasLimit {
       get { return result.hasLimit; }
      }
      public global::Mysqlx.Crud.Limit Limit {
        get { return result.Limit; }
        set { SetLimit(value); }
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = value;
        return this;
      }
      public Builder SetLimit(global::Mysqlx.Crud.Limit.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLimit = true;
        result.limit_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLimit(global::Mysqlx.Crud.Limit value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLimit &&
            result.limit_ != global::Mysqlx.Crud.Limit.DefaultInstance) {
            result.limit_ = global::Mysqlx.Crud.Limit.CreateBuilder(result.limit_).MergeFrom(value).BuildPartial();
        } else {
          result.limit_ = value;
        }
        result.hasLimit = true;
        return this;
      }
      public Builder ClearLimit() {
        PrepareBuilder();
        result.hasLimit = false;
        result.limit_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Crud.Order> OrderList {
        get { return PrepareBuilder().order_; }
      }
      public int OrderCount {
        get { return result.OrderCount; }
      }
      public global::Mysqlx.Crud.Order GetOrder(int index) {
        return result.GetOrder(index);
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_[index] = value;
        return this;
      }
      public Builder SetOrder(int index, global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.order_.Add(value);
        return this;
      }
      public Builder AddOrder(global::Mysqlx.Crud.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.order_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeOrder(scg::IEnumerable<global::Mysqlx.Crud.Order> values) {
        PrepareBuilder();
        result.order_.Add(values);
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.order_.Clear();
        return this;
      }
    }
    static Delete() {
      object.ReferenceEquals(global::Mysqlx.Crud.MysqlxCrud.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
