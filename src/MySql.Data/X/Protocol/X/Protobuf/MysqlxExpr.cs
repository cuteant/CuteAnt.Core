// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Mysqlx.Expr {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal static partial class MysqlxExpr {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Expr__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Expr, global::Mysqlx.Expr.Expr.Builder> internal__static_Mysqlx_Expr_Expr__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Identifier__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Identifier, global::Mysqlx.Expr.Identifier.Builder> internal__static_Mysqlx_Expr_Identifier__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.DocumentPathItem, global::Mysqlx.Expr.DocumentPathItem.Builder> internal__static_Mysqlx_Expr_DocumentPathItem__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.ColumnIdentifier, global::Mysqlx.Expr.ColumnIdentifier.Builder> internal__static_Mysqlx_Expr_ColumnIdentifier__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_FunctionCall__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.FunctionCall, global::Mysqlx.Expr.FunctionCall.Builder> internal__static_Mysqlx_Expr_FunctionCall__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Operator__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Operator, global::Mysqlx.Expr.Operator.Builder> internal__static_Mysqlx_Expr_Operator__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Object__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Object, global::Mysqlx.Expr.Object.Builder> internal__static_Mysqlx_Expr_Object__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Object_ObjectField__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Object.Types.ObjectField, global::Mysqlx.Expr.Object.Types.ObjectField.Builder> internal__static_Mysqlx_Expr_Object_ObjectField__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Mysqlx_Expr_Array__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Array, global::Mysqlx.Expr.Array.Builder> internal__static_Mysqlx_Expr_Array__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static MysqlxExpr() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChFteXNxbHhfZXhwci5wcm90bxILTXlzcWx4LkV4cHIaFm15c3FseF9kYXRh", 
            "dHlwZXMucHJvdG8ixAMKBEV4cHISJAoEdHlwZRgBIAIoDjIWLk15c3FseC5F", 
            "eHByLkV4cHIuVHlwZRIxCgppZGVudGlmaWVyGAIgASgLMh0uTXlzcWx4LkV4", 
            "cHIuQ29sdW1uSWRlbnRpZmllchIQCgh2YXJpYWJsZRgDIAEoCRIpCgdsaXRl", 
            "cmFsGAQgASgLMhguTXlzcWx4LkRhdGF0eXBlcy5TY2FsYXISMAoNZnVuY3Rp", 
            "b25fY2FsbBgFIAEoCzIZLk15c3FseC5FeHByLkZ1bmN0aW9uQ2FsbBInCghv", 
            "cGVyYXRvchgGIAEoCzIVLk15c3FseC5FeHByLk9wZXJhdG9yEhAKCHBvc2l0", 
            "aW9uGAcgASgNEiMKBm9iamVjdBgIIAEoCzITLk15c3FseC5FeHByLk9iamVj", 
            "dBIhCgVhcnJheRgJIAEoCzISLk15c3FseC5FeHByLkFycmF5InEKBFR5cGUS", 
            "CQoFSURFTlQQARILCgdMSVRFUkFMEAISDAoIVkFSSUFCTEUQAxINCglGVU5D", 
            "X0NBTEwQBBIMCghPUEVSQVRPUhAFEg8KC1BMQUNFSE9MREVSEAYSCgoGT0JK", 
            "RUNUEAcSCQoFQVJSQVkQCCIvCgpJZGVudGlmaWVyEgwKBG5hbWUYASACKAkS", 
            "EwoLc2NoZW1hX25hbWUYAiABKAkiywEKEERvY3VtZW50UGF0aEl0ZW0SMAoE", 
            "dHlwZRgBIAIoDjIiLk15c3FseC5FeHByLkRvY3VtZW50UGF0aEl0ZW0uVHlw", 
            "ZRINCgV2YWx1ZRgCIAEoCRINCgVpbmRleBgDIAEoDSJnCgRUeXBlEgoKBk1F", 
            "TUJFUhABEhMKD01FTUJFUl9BU1RFUklTSxACEg8KC0FSUkFZX0lOREVYEAMS", 
            "GAoUQVJSQVlfSU5ERVhfQVNURVJJU0sQBBITCg9ET1VCTEVfQVNURVJJU0sQ", 
            "BSJ/ChBDb2x1bW5JZGVudGlmaWVyEjQKDWRvY3VtZW50X3BhdGgYASADKAsy", 
            "HS5NeXNxbHguRXhwci5Eb2N1bWVudFBhdGhJdGVtEgwKBG5hbWUYAiABKAkS", 
            "EgoKdGFibGVfbmFtZRgDIAEoCRITCgtzY2hlbWFfbmFtZRgEIAEoCSJXCgxG", 
            "dW5jdGlvbkNhbGwSJQoEbmFtZRgBIAIoCzIXLk15c3FseC5FeHByLklkZW50", 
            "aWZpZXISIAoFcGFyYW0YAiADKAsyES5NeXNxbHguRXhwci5FeHByIjoKCE9w", 
            "ZXJhdG9yEgwKBG5hbWUYASACKAkSIAoFcGFyYW0YAiADKAsyES5NeXNxbHgu", 
            "RXhwci5FeHByInQKBk9iamVjdBIsCgNmbGQYASADKAsyHy5NeXNxbHguRXhw", 
            "ci5PYmplY3QuT2JqZWN0RmllbGQaPAoLT2JqZWN0RmllbGQSCwoDa2V5GAEg", 
            "AigJEiAKBXZhbHVlGAIgAigLMhEuTXlzcWx4LkV4cHIuRXhwciIpCgVBcnJh", 
            "eRIgCgV2YWx1ZRgBIAMoCzIRLk15c3FseC5FeHByLkV4cHJCHgocY29tLm15", 
          "c3FsLmNqLm15c3FseC5wcm90b2J1Zg=="));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Mysqlx_Expr_Expr__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Mysqlx_Expr_Expr__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Expr, global::Mysqlx.Expr.Expr.Builder>(internal__static_Mysqlx_Expr_Expr__Descriptor,
                new string[] { "Type", "Identifier", "Variable", "Literal", "FunctionCall", "Operator", "Position", "Object", "Array", });
        internal__static_Mysqlx_Expr_Identifier__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Mysqlx_Expr_Identifier__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Identifier, global::Mysqlx.Expr.Identifier.Builder>(internal__static_Mysqlx_Expr_Identifier__Descriptor,
                new string[] { "Name", "SchemaName", });
        internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Mysqlx_Expr_DocumentPathItem__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.DocumentPathItem, global::Mysqlx.Expr.DocumentPathItem.Builder>(internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor,
                new string[] { "Type", "Value", "Index", });
        internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Mysqlx_Expr_ColumnIdentifier__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.ColumnIdentifier, global::Mysqlx.Expr.ColumnIdentifier.Builder>(internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor,
                new string[] { "DocumentPath", "Name", "TableName", "SchemaName", });
        internal__static_Mysqlx_Expr_FunctionCall__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Mysqlx_Expr_FunctionCall__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.FunctionCall, global::Mysqlx.Expr.FunctionCall.Builder>(internal__static_Mysqlx_Expr_FunctionCall__Descriptor,
                new string[] { "Name", "Param", });
        internal__static_Mysqlx_Expr_Operator__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Mysqlx_Expr_Operator__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Operator, global::Mysqlx.Expr.Operator.Builder>(internal__static_Mysqlx_Expr_Operator__Descriptor,
                new string[] { "Name", "Param", });
        internal__static_Mysqlx_Expr_Object__Descriptor = Descriptor.MessageTypes[6];
        internal__static_Mysqlx_Expr_Object__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Object, global::Mysqlx.Expr.Object.Builder>(internal__static_Mysqlx_Expr_Object__Descriptor,
                new string[] { "Fld", });
        internal__static_Mysqlx_Expr_Object_ObjectField__Descriptor = internal__static_Mysqlx_Expr_Object__Descriptor.NestedTypes[0];
        internal__static_Mysqlx_Expr_Object_ObjectField__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Object.Types.ObjectField, global::Mysqlx.Expr.Object.Types.ObjectField.Builder>(internal__static_Mysqlx_Expr_Object_ObjectField__Descriptor,
                new string[] { "Key", "Value", });
        internal__static_Mysqlx_Expr_Array__Descriptor = Descriptor.MessageTypes[7];
        internal__static_Mysqlx_Expr_Array__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Mysqlx.Expr.Array, global::Mysqlx.Expr.Array.Builder>(internal__static_Mysqlx_Expr_Array__Descriptor,
                new string[] { "Value", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::Mysqlx.Datatypes.MysqlxDatatypes.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Expr : pb::GeneratedMessage<Expr, Expr.Builder> {
    private Expr() { }
    private static readonly Expr defaultInstance = new Expr().MakeReadOnly();
    private static readonly string[] _exprFieldNames = new string[] { "array", "function_call", "identifier", "literal", "object", "operator", "position", "type", "variable" };
    private static readonly uint[] _exprFieldTags = new uint[] { 74, 42, 18, 34, 66, 50, 56, 8, 26 };
    public static Expr DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Expr DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Expr ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Expr__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Expr, Expr.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Expr__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Type {
        IDENT = 1,
        LITERAL = 2,
        VARIABLE = 3,
        FUNC_CALL = 4,
        OPERATOR = 5,
        PLACEHOLDER = 6,
        OBJECT = 7,
        ARRAY = 8,
      }
      
    }
    #endregion
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::Mysqlx.Expr.Expr.Types.Type type_ = global::Mysqlx.Expr.Expr.Types.Type.IDENT;
    public bool HasType {
      get { return hasType; }
    }
    public global::Mysqlx.Expr.Expr.Types.Type Type {
      get { return type_; }
    }
    
    public const int IdentifierFieldNumber = 2;
    private bool hasIdentifier;
    private global::Mysqlx.Expr.ColumnIdentifier identifier_;
    public bool HasIdentifier {
      get { return hasIdentifier; }
    }
    public global::Mysqlx.Expr.ColumnIdentifier Identifier {
      get { return identifier_ ?? global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance; }
    }
    
    public const int VariableFieldNumber = 3;
    private bool hasVariable;
    private string variable_ = "";
    public bool HasVariable {
      get { return hasVariable; }
    }
    public string Variable {
      get { return variable_; }
    }
    
    public const int LiteralFieldNumber = 4;
    private bool hasLiteral;
    private global::Mysqlx.Datatypes.Scalar literal_;
    public bool HasLiteral {
      get { return hasLiteral; }
    }
    public global::Mysqlx.Datatypes.Scalar Literal {
      get { return literal_ ?? global::Mysqlx.Datatypes.Scalar.DefaultInstance; }
    }
    
    public const int FunctionCallFieldNumber = 5;
    private bool hasFunctionCall;
    private global::Mysqlx.Expr.FunctionCall functionCall_;
    public bool HasFunctionCall {
      get { return hasFunctionCall; }
    }
    public global::Mysqlx.Expr.FunctionCall FunctionCall {
      get { return functionCall_ ?? global::Mysqlx.Expr.FunctionCall.DefaultInstance; }
    }
    
    public const int OperatorFieldNumber = 6;
    private bool hasOperator;
    private global::Mysqlx.Expr.Operator operator_;
    public bool HasOperator {
      get { return hasOperator; }
    }
    public global::Mysqlx.Expr.Operator Operator {
      get { return operator_ ?? global::Mysqlx.Expr.Operator.DefaultInstance; }
    }
    
    public const int PositionFieldNumber = 7;
    private bool hasPosition;
    private uint position_;
    public bool HasPosition {
      get { return hasPosition; }
    }
    [global::System.CLSCompliant(false)]
    public uint Position {
      get { return position_; }
    }
    
    public const int ObjectFieldNumber = 8;
    private bool hasObject;
    private global::Mysqlx.Expr.Object object_;
    public bool HasObject {
      get { return hasObject; }
    }
    public global::Mysqlx.Expr.Object Object {
      get { return object_ ?? global::Mysqlx.Expr.Object.DefaultInstance; }
    }
    
    public const int ArrayFieldNumber = 9;
    private bool hasArray;
    private global::Mysqlx.Expr.Array array_;
    public bool HasArray {
      get { return hasArray; }
    }
    public global::Mysqlx.Expr.Array Array {
      get { return array_ ?? global::Mysqlx.Expr.Array.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        if (HasIdentifier) {
          if (!Identifier.IsInitialized) return false;
        }
        if (HasLiteral) {
          if (!Literal.IsInitialized) return false;
        }
        if (HasFunctionCall) {
          if (!FunctionCall.IsInitialized) return false;
        }
        if (HasOperator) {
          if (!Operator.IsInitialized) return false;
        }
        if (HasObject) {
          if (!Object.IsInitialized) return false;
        }
        if (HasArray) {
          if (!Array.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _exprFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[7], (int) Type, Type);
      }
      if (hasIdentifier) {
        output.WriteMessage(2, field_names[2], Identifier);
      }
      if (hasVariable) {
        output.WriteString(3, field_names[8], Variable);
      }
      if (hasLiteral) {
        output.WriteMessage(4, field_names[3], Literal);
      }
      if (hasFunctionCall) {
        output.WriteMessage(5, field_names[1], FunctionCall);
      }
      if (hasOperator) {
        output.WriteMessage(6, field_names[5], Operator);
      }
      if (hasPosition) {
        output.WriteUInt32(7, field_names[6], Position);
      }
      if (hasObject) {
        output.WriteMessage(8, field_names[4], Object);
      }
      if (hasArray) {
        output.WriteMessage(9, field_names[0], Array);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasType) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
      }
      if (hasIdentifier) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Identifier);
      }
      if (hasVariable) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Variable);
      }
      if (hasLiteral) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, Literal);
      }
      if (hasFunctionCall) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, FunctionCall);
      }
      if (hasOperator) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, Operator);
      }
      if (hasPosition) {
        size += pb::CodedOutputStream.ComputeUInt32Size(7, Position);
      }
      if (hasObject) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, Object);
      }
      if (hasArray) {
        size += pb::CodedOutputStream.ComputeMessageSize(9, Array);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Expr ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Expr ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Expr ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Expr ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Expr ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Expr ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Expr ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Expr ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Expr ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Expr ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Expr MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Expr prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Expr, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Expr cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Expr result;
      
      private Expr PrepareBuilder() {
        if (resultIsReadOnly) {
          Expr original = result;
          result = new Expr();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Expr MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Expr.Descriptor; }
      }
      
      public override Expr DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Expr.DefaultInstance; }
      }
      
      public override Expr BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Expr) {
          return MergeFrom((Expr) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Expr other) {
        if (other == global::Mysqlx.Expr.Expr.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasIdentifier) {
          MergeIdentifier(other.Identifier);
        }
        if (other.HasVariable) {
          Variable = other.Variable;
        }
        if (other.HasLiteral) {
          MergeLiteral(other.Literal);
        }
        if (other.HasFunctionCall) {
          MergeFunctionCall(other.FunctionCall);
        }
        if (other.HasOperator) {
          MergeOperator(other.Operator);
        }
        if (other.HasPosition) {
          Position = other.Position;
        }
        if (other.HasObject) {
          MergeObject(other.Object);
        }
        if (other.HasArray) {
          MergeArray(other.Array);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_exprFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _exprFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::Mysqlx.Expr.ColumnIdentifier.Builder subBuilder = global::Mysqlx.Expr.ColumnIdentifier.CreateBuilder();
              if (result.hasIdentifier) {
                subBuilder.MergeFrom(Identifier);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Identifier = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              result.hasVariable = input.ReadString(ref result.variable_);
              break;
            }
            case 34: {
              global::Mysqlx.Datatypes.Scalar.Builder subBuilder = global::Mysqlx.Datatypes.Scalar.CreateBuilder();
              if (result.hasLiteral) {
                subBuilder.MergeFrom(Literal);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Literal = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::Mysqlx.Expr.FunctionCall.Builder subBuilder = global::Mysqlx.Expr.FunctionCall.CreateBuilder();
              if (result.hasFunctionCall) {
                subBuilder.MergeFrom(FunctionCall);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              FunctionCall = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::Mysqlx.Expr.Operator.Builder subBuilder = global::Mysqlx.Expr.Operator.CreateBuilder();
              if (result.hasOperator) {
                subBuilder.MergeFrom(Operator);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Operator = subBuilder.BuildPartial();
              break;
            }
            case 56: {
              result.hasPosition = input.ReadUInt32(ref result.position_);
              break;
            }
            case 66: {
              global::Mysqlx.Expr.Object.Builder subBuilder = global::Mysqlx.Expr.Object.CreateBuilder();
              if (result.hasObject) {
                subBuilder.MergeFrom(Object);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Object = subBuilder.BuildPartial();
              break;
            }
            case 74: {
              global::Mysqlx.Expr.Array.Builder subBuilder = global::Mysqlx.Expr.Array.CreateBuilder();
              if (result.hasArray) {
                subBuilder.MergeFrom(Array);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Array = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::Mysqlx.Expr.Expr.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::Mysqlx.Expr.Expr.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::Mysqlx.Expr.Expr.Types.Type.IDENT;
        return this;
      }
      
      public bool HasIdentifier {
       get { return result.hasIdentifier; }
      }
      public global::Mysqlx.Expr.ColumnIdentifier Identifier {
        get { return result.Identifier; }
        set { SetIdentifier(value); }
      }
      public Builder SetIdentifier(global::Mysqlx.Expr.ColumnIdentifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIdentifier = true;
        result.identifier_ = value;
        return this;
      }
      public Builder SetIdentifier(global::Mysqlx.Expr.ColumnIdentifier.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasIdentifier = true;
        result.identifier_ = builderForValue.Build();
        return this;
      }
      public Builder MergeIdentifier(global::Mysqlx.Expr.ColumnIdentifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasIdentifier &&
            result.identifier_ != global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance) {
            result.identifier_ = global::Mysqlx.Expr.ColumnIdentifier.CreateBuilder(result.identifier_).MergeFrom(value).BuildPartial();
        } else {
          result.identifier_ = value;
        }
        result.hasIdentifier = true;
        return this;
      }
      public Builder ClearIdentifier() {
        PrepareBuilder();
        result.hasIdentifier = false;
        result.identifier_ = null;
        return this;
      }
      
      public bool HasVariable {
        get { return result.hasVariable; }
      }
      public string Variable {
        get { return result.Variable; }
        set { SetVariable(value); }
      }
      public Builder SetVariable(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVariable = true;
        result.variable_ = value;
        return this;
      }
      public Builder ClearVariable() {
        PrepareBuilder();
        result.hasVariable = false;
        result.variable_ = "";
        return this;
      }
      
      public bool HasLiteral {
       get { return result.hasLiteral; }
      }
      public global::Mysqlx.Datatypes.Scalar Literal {
        get { return result.Literal; }
        set { SetLiteral(value); }
      }
      public Builder SetLiteral(global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLiteral = true;
        result.literal_ = value;
        return this;
      }
      public Builder SetLiteral(global::Mysqlx.Datatypes.Scalar.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLiteral = true;
        result.literal_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLiteral(global::Mysqlx.Datatypes.Scalar value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLiteral &&
            result.literal_ != global::Mysqlx.Datatypes.Scalar.DefaultInstance) {
            result.literal_ = global::Mysqlx.Datatypes.Scalar.CreateBuilder(result.literal_).MergeFrom(value).BuildPartial();
        } else {
          result.literal_ = value;
        }
        result.hasLiteral = true;
        return this;
      }
      public Builder ClearLiteral() {
        PrepareBuilder();
        result.hasLiteral = false;
        result.literal_ = null;
        return this;
      }
      
      public bool HasFunctionCall {
       get { return result.hasFunctionCall; }
      }
      public global::Mysqlx.Expr.FunctionCall FunctionCall {
        get { return result.FunctionCall; }
        set { SetFunctionCall(value); }
      }
      public Builder SetFunctionCall(global::Mysqlx.Expr.FunctionCall value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFunctionCall = true;
        result.functionCall_ = value;
        return this;
      }
      public Builder SetFunctionCall(global::Mysqlx.Expr.FunctionCall.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasFunctionCall = true;
        result.functionCall_ = builderForValue.Build();
        return this;
      }
      public Builder MergeFunctionCall(global::Mysqlx.Expr.FunctionCall value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasFunctionCall &&
            result.functionCall_ != global::Mysqlx.Expr.FunctionCall.DefaultInstance) {
            result.functionCall_ = global::Mysqlx.Expr.FunctionCall.CreateBuilder(result.functionCall_).MergeFrom(value).BuildPartial();
        } else {
          result.functionCall_ = value;
        }
        result.hasFunctionCall = true;
        return this;
      }
      public Builder ClearFunctionCall() {
        PrepareBuilder();
        result.hasFunctionCall = false;
        result.functionCall_ = null;
        return this;
      }
      
      public bool HasOperator {
       get { return result.hasOperator; }
      }
      public global::Mysqlx.Expr.Operator Operator {
        get { return result.Operator; }
        set { SetOperator(value); }
      }
      public Builder SetOperator(global::Mysqlx.Expr.Operator value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOperator = true;
        result.operator_ = value;
        return this;
      }
      public Builder SetOperator(global::Mysqlx.Expr.Operator.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOperator = true;
        result.operator_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOperator(global::Mysqlx.Expr.Operator value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOperator &&
            result.operator_ != global::Mysqlx.Expr.Operator.DefaultInstance) {
            result.operator_ = global::Mysqlx.Expr.Operator.CreateBuilder(result.operator_).MergeFrom(value).BuildPartial();
        } else {
          result.operator_ = value;
        }
        result.hasOperator = true;
        return this;
      }
      public Builder ClearOperator() {
        PrepareBuilder();
        result.hasOperator = false;
        result.operator_ = null;
        return this;
      }
      
      public bool HasPosition {
        get { return result.hasPosition; }
      }
      [global::System.CLSCompliant(false)]
      public uint Position {
        get { return result.Position; }
        set { SetPosition(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetPosition(uint value) {
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = value;
        return this;
      }
      public Builder ClearPosition() {
        PrepareBuilder();
        result.hasPosition = false;
        result.position_ = 0;
        return this;
      }
      
      public bool HasObject {
       get { return result.hasObject; }
      }
      public global::Mysqlx.Expr.Object Object {
        get { return result.Object; }
        set { SetObject(value); }
      }
      public Builder SetObject(global::Mysqlx.Expr.Object value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasObject = true;
        result.object_ = value;
        return this;
      }
      public Builder SetObject(global::Mysqlx.Expr.Object.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasObject = true;
        result.object_ = builderForValue.Build();
        return this;
      }
      public Builder MergeObject(global::Mysqlx.Expr.Object value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasObject &&
            result.object_ != global::Mysqlx.Expr.Object.DefaultInstance) {
            result.object_ = global::Mysqlx.Expr.Object.CreateBuilder(result.object_).MergeFrom(value).BuildPartial();
        } else {
          result.object_ = value;
        }
        result.hasObject = true;
        return this;
      }
      public Builder ClearObject() {
        PrepareBuilder();
        result.hasObject = false;
        result.object_ = null;
        return this;
      }
      
      public bool HasArray {
       get { return result.hasArray; }
      }
      public global::Mysqlx.Expr.Array Array {
        get { return result.Array; }
        set { SetArray(value); }
      }
      public Builder SetArray(global::Mysqlx.Expr.Array value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasArray = true;
        result.array_ = value;
        return this;
      }
      public Builder SetArray(global::Mysqlx.Expr.Array.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasArray = true;
        result.array_ = builderForValue.Build();
        return this;
      }
      public Builder MergeArray(global::Mysqlx.Expr.Array value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasArray &&
            result.array_ != global::Mysqlx.Expr.Array.DefaultInstance) {
            result.array_ = global::Mysqlx.Expr.Array.CreateBuilder(result.array_).MergeFrom(value).BuildPartial();
        } else {
          result.array_ = value;
        }
        result.hasArray = true;
        return this;
      }
      public Builder ClearArray() {
        PrepareBuilder();
        result.hasArray = false;
        result.array_ = null;
        return this;
      }
    }
    static Expr() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Identifier : pb::GeneratedMessage<Identifier, Identifier.Builder> {
    private Identifier() { }
    private static readonly Identifier defaultInstance = new Identifier().MakeReadOnly();
    private static readonly string[] _identifierFieldNames = new string[] { "name", "schema_name" };
    private static readonly uint[] _identifierFieldTags = new uint[] { 10, 18 };
    public static Identifier DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Identifier DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Identifier ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Identifier__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Identifier, Identifier.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Identifier__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int SchemaNameFieldNumber = 2;
    private bool hasSchemaName;
    private string schemaName_ = "";
    public bool HasSchemaName {
      get { return hasSchemaName; }
    }
    public string SchemaName {
      get { return schemaName_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _identifierFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (hasSchemaName) {
        output.WriteString(2, field_names[1], SchemaName);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Name);
      }
      if (hasSchemaName) {
        size += pb::CodedOutputStream.ComputeStringSize(2, SchemaName);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Identifier ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Identifier ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Identifier ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Identifier ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Identifier ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Identifier ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Identifier ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Identifier ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Identifier ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Identifier ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Identifier MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Identifier prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Identifier, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Identifier cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Identifier result;
      
      private Identifier PrepareBuilder() {
        if (resultIsReadOnly) {
          Identifier original = result;
          result = new Identifier();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Identifier MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Identifier.Descriptor; }
      }
      
      public override Identifier DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Identifier.DefaultInstance; }
      }
      
      public override Identifier BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Identifier) {
          return MergeFrom((Identifier) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Identifier other) {
        if (other == global::Mysqlx.Expr.Identifier.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasSchemaName) {
          SchemaName = other.SchemaName;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_identifierFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _identifierFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              result.hasSchemaName = input.ReadString(ref result.schemaName_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasSchemaName {
        get { return result.hasSchemaName; }
      }
      public string SchemaName {
        get { return result.SchemaName; }
        set { SetSchemaName(value); }
      }
      public Builder SetSchemaName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSchemaName = true;
        result.schemaName_ = value;
        return this;
      }
      public Builder ClearSchemaName() {
        PrepareBuilder();
        result.hasSchemaName = false;
        result.schemaName_ = "";
        return this;
      }
    }
    static Identifier() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class DocumentPathItem : pb::GeneratedMessage<DocumentPathItem, DocumentPathItem.Builder> {
    private DocumentPathItem() { }
    private static readonly DocumentPathItem defaultInstance = new DocumentPathItem().MakeReadOnly();
    private static readonly string[] _documentPathItemFieldNames = new string[] { "index", "type", "value" };
    private static readonly uint[] _documentPathItemFieldTags = new uint[] { 24, 8, 18 };
    public static DocumentPathItem DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override DocumentPathItem DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override DocumentPathItem ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_DocumentPathItem__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<DocumentPathItem, DocumentPathItem.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_DocumentPathItem__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Type {
        MEMBER = 1,
        MEMBER_ASTERISK = 2,
        ARRAY_INDEX = 3,
        ARRAY_INDEX_ASTERISK = 4,
        DOUBLE_ASTERISK = 5,
      }
      
    }
    #endregion
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::Mysqlx.Expr.DocumentPathItem.Types.Type type_ = global::Mysqlx.Expr.DocumentPathItem.Types.Type.MEMBER;
    public bool HasType {
      get { return hasType; }
    }
    public global::Mysqlx.Expr.DocumentPathItem.Types.Type Type {
      get { return type_; }
    }
    
    public const int ValueFieldNumber = 2;
    private bool hasValue;
    private string value_ = "";
    public bool HasValue {
      get { return hasValue; }
    }
    public string Value {
      get { return value_; }
    }
    
    public const int IndexFieldNumber = 3;
    private bool hasIndex;
    private uint index_;
    public bool HasIndex {
      get { return hasIndex; }
    }
    [global::System.CLSCompliant(false)]
    public uint Index {
      get { return index_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _documentPathItemFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[1], (int) Type, Type);
      }
      if (hasValue) {
        output.WriteString(2, field_names[2], Value);
      }
      if (hasIndex) {
        output.WriteUInt32(3, field_names[0], Index);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasType) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
      }
      if (hasValue) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Value);
      }
      if (hasIndex) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, Index);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static DocumentPathItem ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static DocumentPathItem ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static DocumentPathItem ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DocumentPathItem ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private DocumentPathItem MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(DocumentPathItem prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<DocumentPathItem, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(DocumentPathItem cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private DocumentPathItem result;
      
      private DocumentPathItem PrepareBuilder() {
        if (resultIsReadOnly) {
          DocumentPathItem original = result;
          result = new DocumentPathItem();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override DocumentPathItem MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.DocumentPathItem.Descriptor; }
      }
      
      public override DocumentPathItem DefaultInstanceForType {
        get { return global::Mysqlx.Expr.DocumentPathItem.DefaultInstance; }
      }
      
      public override DocumentPathItem BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is DocumentPathItem) {
          return MergeFrom((DocumentPathItem) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(DocumentPathItem other) {
        if (other == global::Mysqlx.Expr.DocumentPathItem.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasValue) {
          Value = other.Value;
        }
        if (other.HasIndex) {
          Index = other.Index;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_documentPathItemFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _documentPathItemFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasValue = input.ReadString(ref result.value_);
              break;
            }
            case 24: {
              result.hasIndex = input.ReadUInt32(ref result.index_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::Mysqlx.Expr.DocumentPathItem.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::Mysqlx.Expr.DocumentPathItem.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::Mysqlx.Expr.DocumentPathItem.Types.Type.MEMBER;
        return this;
      }
      
      public bool HasValue {
        get { return result.hasValue; }
      }
      public string Value {
        get { return result.Value; }
        set { SetValue(value); }
      }
      public Builder SetValue(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = value;
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.hasValue = false;
        result.value_ = "";
        return this;
      }
      
      public bool HasIndex {
        get { return result.hasIndex; }
      }
      [global::System.CLSCompliant(false)]
      public uint Index {
        get { return result.Index; }
        set { SetIndex(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetIndex(uint value) {
        PrepareBuilder();
        result.hasIndex = true;
        result.index_ = value;
        return this;
      }
      public Builder ClearIndex() {
        PrepareBuilder();
        result.hasIndex = false;
        result.index_ = 0;
        return this;
      }
    }
    static DocumentPathItem() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class ColumnIdentifier : pb::GeneratedMessage<ColumnIdentifier, ColumnIdentifier.Builder> {
    private ColumnIdentifier() { }
    private static readonly ColumnIdentifier defaultInstance = new ColumnIdentifier().MakeReadOnly();
    private static readonly string[] _columnIdentifierFieldNames = new string[] { "document_path", "name", "schema_name", "table_name" };
    private static readonly uint[] _columnIdentifierFieldTags = new uint[] { 10, 18, 34, 26 };
    public static ColumnIdentifier DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ColumnIdentifier DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ColumnIdentifier ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_ColumnIdentifier__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ColumnIdentifier, ColumnIdentifier.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_ColumnIdentifier__FieldAccessorTable; }
    }
    
    public const int DocumentPathFieldNumber = 1;
    private pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem> documentPath_ = new pbc::PopsicleList<global::Mysqlx.Expr.DocumentPathItem>();
    public scg::IList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
      get { return documentPath_; }
    }
    public int DocumentPathCount {
      get { return documentPath_.Count; }
    }
    public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
      return documentPath_[index];
    }
    
    public const int NameFieldNumber = 2;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int TableNameFieldNumber = 3;
    private bool hasTableName;
    private string tableName_ = "";
    public bool HasTableName {
      get { return hasTableName; }
    }
    public string TableName {
      get { return tableName_; }
    }
    
    public const int SchemaNameFieldNumber = 4;
    private bool hasSchemaName;
    private string schemaName_ = "";
    public bool HasSchemaName {
      get { return hasSchemaName; }
    }
    public string SchemaName {
      get { return schemaName_; }
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _columnIdentifierFieldNames;
      if (documentPath_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], documentPath_);
      }
      if (hasName) {
        output.WriteString(2, field_names[1], Name);
      }
      if (hasTableName) {
        output.WriteString(3, field_names[3], TableName);
      }
      if (hasSchemaName) {
        output.WriteString(4, field_names[2], SchemaName);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Mysqlx.Expr.DocumentPathItem element in DocumentPathList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Name);
      }
      if (hasTableName) {
        size += pb::CodedOutputStream.ComputeStringSize(3, TableName);
      }
      if (hasSchemaName) {
        size += pb::CodedOutputStream.ComputeStringSize(4, SchemaName);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ColumnIdentifier ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ColumnIdentifier ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ColumnIdentifier ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ColumnIdentifier ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ColumnIdentifier MakeReadOnly() {
      documentPath_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ColumnIdentifier prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ColumnIdentifier, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ColumnIdentifier cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ColumnIdentifier result;
      
      private ColumnIdentifier PrepareBuilder() {
        if (resultIsReadOnly) {
          ColumnIdentifier original = result;
          result = new ColumnIdentifier();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ColumnIdentifier MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.ColumnIdentifier.Descriptor; }
      }
      
      public override ColumnIdentifier DefaultInstanceForType {
        get { return global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance; }
      }
      
      public override ColumnIdentifier BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ColumnIdentifier) {
          return MergeFrom((ColumnIdentifier) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ColumnIdentifier other) {
        if (other == global::Mysqlx.Expr.ColumnIdentifier.DefaultInstance) return this;
        PrepareBuilder();
        if (other.documentPath_.Count != 0) {
          result.documentPath_.Add(other.documentPath_);
        }
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasTableName) {
          TableName = other.TableName;
        }
        if (other.HasSchemaName) {
          SchemaName = other.SchemaName;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_columnIdentifierFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _columnIdentifierFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.documentPath_, global::Mysqlx.Expr.DocumentPathItem.DefaultInstance, extensionRegistry);
              break;
            }
            case 18: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 26: {
              result.hasTableName = input.ReadString(ref result.tableName_);
              break;
            }
            case 34: {
              result.hasSchemaName = input.ReadString(ref result.schemaName_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.DocumentPathItem> DocumentPathList {
        get { return PrepareBuilder().documentPath_; }
      }
      public int DocumentPathCount {
        get { return result.DocumentPathCount; }
      }
      public global::Mysqlx.Expr.DocumentPathItem GetDocumentPath(int index) {
        return result.GetDocumentPath(index);
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_[index] = value;
        return this;
      }
      public Builder SetDocumentPath(int index, global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.documentPath_.Add(value);
        return this;
      }
      public Builder AddDocumentPath(global::Mysqlx.Expr.DocumentPathItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.documentPath_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeDocumentPath(scg::IEnumerable<global::Mysqlx.Expr.DocumentPathItem> values) {
        PrepareBuilder();
        result.documentPath_.Add(values);
        return this;
      }
      public Builder ClearDocumentPath() {
        PrepareBuilder();
        result.documentPath_.Clear();
        return this;
      }
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasTableName {
        get { return result.hasTableName; }
      }
      public string TableName {
        get { return result.TableName; }
        set { SetTableName(value); }
      }
      public Builder SetTableName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTableName = true;
        result.tableName_ = value;
        return this;
      }
      public Builder ClearTableName() {
        PrepareBuilder();
        result.hasTableName = false;
        result.tableName_ = "";
        return this;
      }
      
      public bool HasSchemaName {
        get { return result.hasSchemaName; }
      }
      public string SchemaName {
        get { return result.SchemaName; }
        set { SetSchemaName(value); }
      }
      public Builder SetSchemaName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSchemaName = true;
        result.schemaName_ = value;
        return this;
      }
      public Builder ClearSchemaName() {
        PrepareBuilder();
        result.hasSchemaName = false;
        result.schemaName_ = "";
        return this;
      }
    }
    static ColumnIdentifier() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class FunctionCall : pb::GeneratedMessage<FunctionCall, FunctionCall.Builder> {
    private FunctionCall() { }
    private static readonly FunctionCall defaultInstance = new FunctionCall().MakeReadOnly();
    private static readonly string[] _functionCallFieldNames = new string[] { "name", "param" };
    private static readonly uint[] _functionCallFieldTags = new uint[] { 10, 18 };
    public static FunctionCall DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override FunctionCall DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override FunctionCall ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_FunctionCall__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<FunctionCall, FunctionCall.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_FunctionCall__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private global::Mysqlx.Expr.Identifier name_;
    public bool HasName {
      get { return hasName; }
    }
    public global::Mysqlx.Expr.Identifier Name {
      get { return name_ ?? global::Mysqlx.Expr.Identifier.DefaultInstance; }
    }
    
    public const int ParamFieldNumber = 2;
    private pbc::PopsicleList<global::Mysqlx.Expr.Expr> param_ = new pbc::PopsicleList<global::Mysqlx.Expr.Expr>();
    public scg::IList<global::Mysqlx.Expr.Expr> ParamList {
      get { return param_; }
    }
    public int ParamCount {
      get { return param_.Count; }
    }
    public global::Mysqlx.Expr.Expr GetParam(int index) {
      return param_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        if (!Name.IsInitialized) return false;
        foreach (global::Mysqlx.Expr.Expr element in ParamList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _functionCallFieldNames;
      if (hasName) {
        output.WriteMessage(1, field_names[0], Name);
      }
      if (param_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], param_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasName) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Name);
      }
      foreach (global::Mysqlx.Expr.Expr element in ParamList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static FunctionCall ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FunctionCall ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FunctionCall ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FunctionCall ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FunctionCall ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FunctionCall ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static FunctionCall ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static FunctionCall ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static FunctionCall ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FunctionCall ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private FunctionCall MakeReadOnly() {
      param_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(FunctionCall prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<FunctionCall, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(FunctionCall cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FunctionCall result;
      
      private FunctionCall PrepareBuilder() {
        if (resultIsReadOnly) {
          FunctionCall original = result;
          result = new FunctionCall();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override FunctionCall MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.FunctionCall.Descriptor; }
      }
      
      public override FunctionCall DefaultInstanceForType {
        get { return global::Mysqlx.Expr.FunctionCall.DefaultInstance; }
      }
      
      public override FunctionCall BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is FunctionCall) {
          return MergeFrom((FunctionCall) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(FunctionCall other) {
        if (other == global::Mysqlx.Expr.FunctionCall.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          MergeName(other.Name);
        }
        if (other.param_.Count != 0) {
          result.param_.Add(other.param_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_functionCallFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _functionCallFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Mysqlx.Expr.Identifier.Builder subBuilder = global::Mysqlx.Expr.Identifier.CreateBuilder();
              if (result.hasName) {
                subBuilder.MergeFrom(Name);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Name = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.param_, global::Mysqlx.Expr.Expr.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
       get { return result.hasName; }
      }
      public global::Mysqlx.Expr.Identifier Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(global::Mysqlx.Expr.Identifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder SetName(global::Mysqlx.Expr.Identifier.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = builderForValue.Build();
        return this;
      }
      public Builder MergeName(global::Mysqlx.Expr.Identifier value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasName &&
            result.name_ != global::Mysqlx.Expr.Identifier.DefaultInstance) {
            result.name_ = global::Mysqlx.Expr.Identifier.CreateBuilder(result.name_).MergeFrom(value).BuildPartial();
        } else {
          result.name_ = value;
        }
        result.hasName = true;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.Expr> ParamList {
        get { return PrepareBuilder().param_; }
      }
      public int ParamCount {
        get { return result.ParamCount; }
      }
      public global::Mysqlx.Expr.Expr GetParam(int index) {
        return result.GetParam(index);
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_[index] = value;
        return this;
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_.Add(value);
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeParam(scg::IEnumerable<global::Mysqlx.Expr.Expr> values) {
        PrepareBuilder();
        result.param_.Add(values);
        return this;
      }
      public Builder ClearParam() {
        PrepareBuilder();
        result.param_.Clear();
        return this;
      }
    }
    static FunctionCall() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Operator : pb::GeneratedMessage<Operator, Operator.Builder> {
    private Operator() { }
    private static readonly Operator defaultInstance = new Operator().MakeReadOnly();
    private static readonly string[] _operatorFieldNames = new string[] { "name", "param" };
    private static readonly uint[] _operatorFieldTags = new uint[] { 10, 18 };
    public static Operator DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Operator DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Operator ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Operator__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Operator, Operator.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Operator__FieldAccessorTable; }
    }
    
    public const int NameFieldNumber = 1;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int ParamFieldNumber = 2;
    private pbc::PopsicleList<global::Mysqlx.Expr.Expr> param_ = new pbc::PopsicleList<global::Mysqlx.Expr.Expr>();
    public scg::IList<global::Mysqlx.Expr.Expr> ParamList {
      get { return param_; }
    }
    public int ParamCount {
      get { return param_.Count; }
    }
    public global::Mysqlx.Expr.Expr GetParam(int index) {
      return param_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasName) return false;
        foreach (global::Mysqlx.Expr.Expr element in ParamList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _operatorFieldNames;
      if (hasName) {
        output.WriteString(1, field_names[0], Name);
      }
      if (param_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], param_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Name);
      }
      foreach (global::Mysqlx.Expr.Expr element in ParamList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Operator ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Operator ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Operator ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Operator ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Operator ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Operator ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Operator ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Operator ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Operator ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Operator ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Operator MakeReadOnly() {
      param_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Operator prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Operator, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Operator cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Operator result;
      
      private Operator PrepareBuilder() {
        if (resultIsReadOnly) {
          Operator original = result;
          result = new Operator();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Operator MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Operator.Descriptor; }
      }
      
      public override Operator DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Operator.DefaultInstance; }
      }
      
      public override Operator BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Operator) {
          return MergeFrom((Operator) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Operator other) {
        if (other == global::Mysqlx.Expr.Operator.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.param_.Count != 0) {
          result.param_.Add(other.param_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_operatorFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _operatorFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.param_, global::Mysqlx.Expr.Expr.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.Expr> ParamList {
        get { return PrepareBuilder().param_; }
      }
      public int ParamCount {
        get { return result.ParamCount; }
      }
      public global::Mysqlx.Expr.Expr GetParam(int index) {
        return result.GetParam(index);
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_[index] = value;
        return this;
      }
      public Builder SetParam(int index, global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.param_.Add(value);
        return this;
      }
      public Builder AddParam(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.param_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeParam(scg::IEnumerable<global::Mysqlx.Expr.Expr> values) {
        PrepareBuilder();
        result.param_.Add(values);
        return this;
      }
      public Builder ClearParam() {
        PrepareBuilder();
        result.param_.Clear();
        return this;
      }
    }
    static Operator() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Object : pb::GeneratedMessage<Object, Object.Builder> {
    private Object() { }
    private static readonly Object defaultInstance = new Object().MakeReadOnly();
    private static readonly string[] _objectFieldNames = new string[] { "fld" };
    private static readonly uint[] _objectFieldTags = new uint[] { 10 };
    public static Object DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Object DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Object ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Object__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Object, Object.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Object__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class ObjectField : pb::GeneratedMessage<ObjectField, ObjectField.Builder> {
        private ObjectField() { }
        private static readonly ObjectField defaultInstance = new ObjectField().MakeReadOnly();
        private static readonly string[] _objectFieldFieldNames = new string[] { "key", "value" };
        private static readonly uint[] _objectFieldFieldTags = new uint[] { 10, 18 };
        public static ObjectField DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override ObjectField DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override ObjectField ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Object_ObjectField__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<ObjectField, ObjectField.Builder> InternalFieldAccessors {
          get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Object_ObjectField__FieldAccessorTable; }
        }
        
        public const int KeyFieldNumber = 1;
        private bool hasKey;
        private string key_ = "";
        public bool HasKey {
          get { return hasKey; }
        }
        public string Key {
          get { return key_; }
        }
        
        public const int ValueFieldNumber = 2;
        private bool hasValue;
        private global::Mysqlx.Expr.Expr value_;
        public bool HasValue {
          get { return hasValue; }
        }
        public global::Mysqlx.Expr.Expr Value {
          get { return value_ ?? global::Mysqlx.Expr.Expr.DefaultInstance; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasKey) return false;
            if (!hasValue) return false;
            if (!Value.IsInitialized) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _objectFieldFieldNames;
          if (hasKey) {
            output.WriteString(1, field_names[0], Key);
          }
          if (hasValue) {
            output.WriteMessage(2, field_names[1], Value);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasKey) {
            size += pb::CodedOutputStream.ComputeStringSize(1, Key);
          }
          if (hasValue) {
            size += pb::CodedOutputStream.ComputeMessageSize(2, Value);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
        public static ObjectField ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ObjectField ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ObjectField ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ObjectField ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ObjectField ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ObjectField ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static ObjectField ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static ObjectField ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static ObjectField ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ObjectField ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private ObjectField MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(ObjectField prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<ObjectField, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(ObjectField cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private ObjectField result;
          
          private ObjectField PrepareBuilder() {
            if (resultIsReadOnly) {
              ObjectField original = result;
              result = new ObjectField();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override ObjectField MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::Mysqlx.Expr.Object.Types.ObjectField.Descriptor; }
          }
          
          public override ObjectField DefaultInstanceForType {
            get { return global::Mysqlx.Expr.Object.Types.ObjectField.DefaultInstance; }
          }
          
          public override ObjectField BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is ObjectField) {
              return MergeFrom((ObjectField) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(ObjectField other) {
            if (other == global::Mysqlx.Expr.Object.Types.ObjectField.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasKey) {
              Key = other.Key;
            }
            if (other.HasValue) {
              MergeValue(other.Value);
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_objectFieldFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _objectFieldFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasKey = input.ReadString(ref result.key_);
                  break;
                }
                case 18: {
                  global::Mysqlx.Expr.Expr.Builder subBuilder = global::Mysqlx.Expr.Expr.CreateBuilder();
                  if (result.hasValue) {
                    subBuilder.MergeFrom(Value);
                  }
                  input.ReadMessage(subBuilder, extensionRegistry);
                  Value = subBuilder.BuildPartial();
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public bool HasKey {
            get { return result.hasKey; }
          }
          public string Key {
            get { return result.Key; }
            set { SetKey(value); }
          }
          public Builder SetKey(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasKey = true;
            result.key_ = value;
            return this;
          }
          public Builder ClearKey() {
            PrepareBuilder();
            result.hasKey = false;
            result.key_ = "";
            return this;
          }
          
          public bool HasValue {
           get { return result.hasValue; }
          }
          public global::Mysqlx.Expr.Expr Value {
            get { return result.Value; }
            set { SetValue(value); }
          }
          public Builder SetValue(global::Mysqlx.Expr.Expr value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasValue = true;
            result.value_ = value;
            return this;
          }
          public Builder SetValue(global::Mysqlx.Expr.Expr.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.hasValue = true;
            result.value_ = builderForValue.Build();
            return this;
          }
          public Builder MergeValue(global::Mysqlx.Expr.Expr value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            if (result.hasValue &&
                result.value_ != global::Mysqlx.Expr.Expr.DefaultInstance) {
                result.value_ = global::Mysqlx.Expr.Expr.CreateBuilder(result.value_).MergeFrom(value).BuildPartial();
            } else {
              result.value_ = value;
            }
            result.hasValue = true;
            return this;
          }
          public Builder ClearValue() {
            PrepareBuilder();
            result.hasValue = false;
            result.value_ = null;
            return this;
          }
        }
        static ObjectField() {
          object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public const int FldFieldNumber = 1;
    private pbc::PopsicleList<global::Mysqlx.Expr.Object.Types.ObjectField> fld_ = new pbc::PopsicleList<global::Mysqlx.Expr.Object.Types.ObjectField>();
    public scg::IList<global::Mysqlx.Expr.Object.Types.ObjectField> FldList {
      get { return fld_; }
    }
    public int FldCount {
      get { return fld_.Count; }
    }
    public global::Mysqlx.Expr.Object.Types.ObjectField GetFld(int index) {
      return fld_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Mysqlx.Expr.Object.Types.ObjectField element in FldList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _objectFieldNames;
      if (fld_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], fld_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Mysqlx.Expr.Object.Types.ObjectField element in FldList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Object ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Object ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Object ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Object ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Object ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Object ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Object ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Object ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Object ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Object ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Object MakeReadOnly() {
      fld_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Object prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Object, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Object cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Object result;
      
      private Object PrepareBuilder() {
        if (resultIsReadOnly) {
          Object original = result;
          result = new Object();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Object MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Object.Descriptor; }
      }
      
      public override Object DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Object.DefaultInstance; }
      }
      
      public override Object BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Object) {
          return MergeFrom((Object) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Object other) {
        if (other == global::Mysqlx.Expr.Object.DefaultInstance) return this;
        PrepareBuilder();
        if (other.fld_.Count != 0) {
          result.fld_.Add(other.fld_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_objectFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _objectFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.fld_, global::Mysqlx.Expr.Object.Types.ObjectField.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.Object.Types.ObjectField> FldList {
        get { return PrepareBuilder().fld_; }
      }
      public int FldCount {
        get { return result.FldCount; }
      }
      public global::Mysqlx.Expr.Object.Types.ObjectField GetFld(int index) {
        return result.GetFld(index);
      }
      public Builder SetFld(int index, global::Mysqlx.Expr.Object.Types.ObjectField value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.fld_[index] = value;
        return this;
      }
      public Builder SetFld(int index, global::Mysqlx.Expr.Object.Types.ObjectField.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.fld_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddFld(global::Mysqlx.Expr.Object.Types.ObjectField value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.fld_.Add(value);
        return this;
      }
      public Builder AddFld(global::Mysqlx.Expr.Object.Types.ObjectField.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.fld_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeFld(scg::IEnumerable<global::Mysqlx.Expr.Object.Types.ObjectField> values) {
        PrepareBuilder();
        result.fld_.Add(values);
        return this;
      }
      public Builder ClearFld() {
        PrepareBuilder();
        result.fld_.Clear();
        return this;
      }
    }
    static Object() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  internal sealed partial class Array : pb::GeneratedMessage<Array, Array.Builder> {
    private Array() { }
    private static readonly Array defaultInstance = new Array().MakeReadOnly();
    private static readonly string[] _arrayFieldNames = new string[] { "value" };
    private static readonly uint[] _arrayFieldTags = new uint[] { 10 };
    public static Array DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Array DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Array ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Array__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Array, Array.Builder> InternalFieldAccessors {
      get { return global::Mysqlx.Expr.MysqlxExpr.internal__static_Mysqlx_Expr_Array__FieldAccessorTable; }
    }
    
    public const int ValueFieldNumber = 1;
    private pbc::PopsicleList<global::Mysqlx.Expr.Expr> value_ = new pbc::PopsicleList<global::Mysqlx.Expr.Expr>();
    public scg::IList<global::Mysqlx.Expr.Expr> ValueList {
      get { return value_; }
    }
    public int ValueCount {
      get { return value_.Count; }
    }
    public global::Mysqlx.Expr.Expr GetValue(int index) {
      return value_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Mysqlx.Expr.Expr element in ValueList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _arrayFieldNames;
      if (value_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], value_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Mysqlx.Expr.Expr element in ValueList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Array ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Array ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Array ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Array ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Array ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Array ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Array ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Array ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Array ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Array ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Array MakeReadOnly() {
      value_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Array prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Array, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Array cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Array result;
      
      private Array PrepareBuilder() {
        if (resultIsReadOnly) {
          Array original = result;
          result = new Array();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Array MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Mysqlx.Expr.Array.Descriptor; }
      }
      
      public override Array DefaultInstanceForType {
        get { return global::Mysqlx.Expr.Array.DefaultInstance; }
      }
      
      public override Array BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Array) {
          return MergeFrom((Array) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Array other) {
        if (other == global::Mysqlx.Expr.Array.DefaultInstance) return this;
        PrepareBuilder();
        if (other.value_.Count != 0) {
          result.value_.Add(other.value_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_arrayFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _arrayFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.value_, global::Mysqlx.Expr.Expr.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Mysqlx.Expr.Expr> ValueList {
        get { return PrepareBuilder().value_; }
      }
      public int ValueCount {
        get { return result.ValueCount; }
      }
      public global::Mysqlx.Expr.Expr GetValue(int index) {
        return result.GetValue(index);
      }
      public Builder SetValue(int index, global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.value_[index] = value;
        return this;
      }
      public Builder SetValue(int index, global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.value_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddValue(global::Mysqlx.Expr.Expr value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.value_.Add(value);
        return this;
      }
      public Builder AddValue(global::Mysqlx.Expr.Expr.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.value_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeValue(scg::IEnumerable<global::Mysqlx.Expr.Expr> values) {
        PrepareBuilder();
        result.value_.Add(values);
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.value_.Clear();
        return this;
      }
    }
    static Array() {
      object.ReferenceEquals(global::Mysqlx.Expr.MysqlxExpr.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
